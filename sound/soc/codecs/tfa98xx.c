/*
 * tfa98xx.c  --  codec driver for TFA98XX
 *
 * Copyright (C) 2014 Xiaomi Corporation
 * Copyright (C) 2016 XiaoMi, Inc.
 *
 * Author: Xiang Xiao <xiaoxiang@xiaomi.com>
 *
 * This program is free software; you can redistribute  it and/or modify it
 * under  the terms of  the GNU General  Public License as published by the
 * Free Software Foundation;  either version 2 of the  License, or (at your
 * option) any later version.
 *
 */

#include <linux/delay.h>
#include <linux/firmware.h>
#include <linux/i2c.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/workqueue.h>
#include <sound/pcm_params.h>
#include <sound/soc.h>
#include <sound/tlv.h>
#include <linux/of.h>

#include "tfa98xx.h"

#define TFA98XX_STATUSREG_UP		(TFA98XX_STATUSREG_PLLS | \
					 TFA98XX_STATUSREG_CLKS | \
					 TFA98XX_STATUSREG_AREFS)
#define TFA98XX_STATUSREG_UP_MSK	(TFA98XX_STATUSREG_PLLS_MSK | \
					 TFA98XX_STATUSREG_MTPB_MSK | \
					 TFA98XX_STATUSREG_CLKS_MSK | \
					 TFA98XX_STATUSREG_AREFS_MSK)

#define TFA98XX_STATUSREG_ERR1		(TFA98XX_STATUSREG_OCDS)
#define TFA98XX_STATUSREG_ERR1_MSK	(TFA98XX_STATUSREG_OCDS_MSK)

#define TFA98XX_STATUSREG_ERR2		(TFA98XX_STATUSREG_ACS | \
					 TFA98XX_STATUSREG_WDS)
#define TFA98XX_STATUSREG_ERR2_MSK	(TFA98XX_STATUSREG_ACS_MSK | \
					 TFA98XX_STATUSREG_WDS_MSK)

#define TFA98XX_I2SCTRL_MSB_J		(2 << TFA98XX_I2SREG_I2SF_POS)
#define TFA98XX_I2SCTRL_PHILIPS		(3 << TFA98XX_I2SREG_I2SF_POS)
#define TFA98XX_I2SCTRL_LSB_J_16	(4 << TFA98XX_I2SREG_I2SF_POS)
#define TFA98XX_I2SCTRL_LSB_J_18	(5 << TFA98XX_I2SREG_I2SF_POS)
#define TFA98XX_I2SCTRL_LSB_J_20	(6 << TFA98XX_I2SREG_I2SF_POS)
#define TFA98XX_I2SCTRL_LSB_J_24	(7 << TFA98XX_I2SREG_I2SF_POS)

#define TFA98XX_I2SCTRL_RATE_08000	(0 << TFA98XX_I2SREG_I2SSR_POS)
#define TFA98XX_I2SCTRL_RATE_11025	(1 << TFA98XX_I2SREG_I2SSR_POS)
#define TFA98XX_I2SCTRL_RATE_12000	(2 << TFA98XX_I2SREG_I2SSR_POS)
#define TFA98XX_I2SCTRL_RATE_16000	(3 << TFA98XX_I2SREG_I2SSR_POS)
#define TFA98XX_I2SCTRL_RATE_22050	(4 << TFA98XX_I2SREG_I2SSR_POS)
#define TFA98XX_I2SCTRL_RATE_24000	(5 << TFA98XX_I2SREG_I2SSR_POS)
#define TFA98XX_I2SCTRL_RATE_32000	(6 << TFA98XX_I2SREG_I2SSR_POS)
#define TFA98XX_I2SCTRL_RATE_44100	(7 << TFA98XX_I2SREG_I2SSR_POS)
#define TFA98XX_I2SCTRL_RATE_48000	(8 << TFA98XX_I2SREG_I2SSR_POS)

#define TFA98XX_MUTE_OFF		0
#define TFA98XX_MUTE_DIGITAL		1
#define TFA98XX_MUTE_AMPLIFIER		2

#define TFA98XX_MODULE_SPEAKERBOOST	(128 + 1)
#define TFA98XX_MODULE_BIQUADFILTERBANK	(128 + 2)

#define TFA98XX_PARAM_SET_LSMODEL	0x06
#define TFA98XX_PARAM_SET_PRESET	0x0D
#define TFA98XX_PARAM_SET_CONFIG	0x0E

#define TFA98XX_FW_BOOT			0
#define TFA98XX_FW_ROM			1
#define TFA98XX_FW_SPEAKER		2
#define TFA98XX_FW_CONFIG		3
#define TFA98XX_FW_PRESET		4
#define TFA98XX_FW_EQUALIZER		5
#define TFA98XX_FW_NUMBER		6

struct tfa98xx_priv {
	struct mutex fw_lock;
	bool fw_chg[TFA98XX_FW_NUMBER];
	char fw_name[TFA98XX_FW_NUMBER][512];
	const struct firmware *fw[TFA98XX_FW_NUMBER];
	struct workqueue_struct *workqueue;
	struct delayed_work monitor_work;
	struct delayed_work download_work;
	struct snd_soc_codec *codec;
	unsigned int pilot_tone;
	unsigned int reg_addr;
	unsigned int fmt;
	bool dsp_crash;
	bool recalib;
};

static int tfa98xx_bulk_read(struct snd_soc_codec *codec,
			     unsigned int reg_,
			     void *data, size_t len)
{
	struct i2c_client *client = to_i2c_client(codec->dev);
	struct i2c_msg msgs[2];
	u8 reg = reg_;
	int ret;

	msgs[0].addr  = client->addr;
	msgs[0].flags = client->flags;
	msgs[0].len   = 1;
	msgs[0].buf   = &reg;
	msgs[1].addr  = client->addr;
	msgs[1].flags = client->flags | I2C_M_RD;
	msgs[1].len   = len;
	msgs[1].buf   = data;

	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
	if (ret > 0)
		ret = 0;

	return ret;
}

static int tfa98xx_bulk_write(struct snd_soc_codec *codec,
			      unsigned int reg,
			      const void *data, size_t len)
{
	struct i2c_client *client = to_i2c_client(codec->dev);
	struct i2c_msg msg;
	u8 buf[len + 1];
	int ret;

	buf[0] = reg;
	memcpy(buf + 1, data, len);

	msg.addr  = client->addr;
	msg.flags = client->flags;
	msg.len   = len + 1;
	msg.buf   = buf;

	ret = i2c_transfer(client->adapter, &msg, 1);
	if (ret > 0)
		ret = 0;

	return ret;
}

static unsigned int tfa98xx_read(struct snd_soc_codec *codec, unsigned int reg)
{
	unsigned int val;
	u8 buf[3];
	int ret;

	if (reg >= codec->driver->reg_cache_size ||
	    snd_soc_codec_volatile_register(codec, reg) ||
	    codec->cache_bypass) {
		if (codec->cache_only)
			return -EINVAL;

		ret = tfa98xx_bulk_read(codec, reg, buf, reg == TFA98XX_CF_MEM ? 3 : 2);
		if (ret < 0)
			return ret;
		else if (reg == TFA98XX_CF_MEM)
			return (buf[0] << 16) | (buf[1] << 8) | buf[2];
		else
			return (buf[0] << 8) | buf[1];
	}

	ret = snd_soc_cache_read(codec, reg, &val);
	if (ret < 0)
		return ret;
	return val;
}

static int tfa98xx_write(struct snd_soc_codec *codec, unsigned int reg,
			 unsigned int value)
{
	u8 buf[3];
	size_t sz;
	int ret;

	if (!snd_soc_codec_volatile_register(codec, reg) &&
	    reg < codec->driver->reg_cache_size &&
	    !codec->cache_bypass) {
		ret = snd_soc_cache_write(codec, reg, value);
		if (ret < 0)
			return ret;
	}

	if (codec->cache_only) {
		codec->cache_sync = 1;
		return 0;
	}

	if (reg == TFA98XX_CF_MEM) {
		buf[0] = value >> 16;
		buf[1] = value >> 8;
		buf[2] = value >> 0;
		sz     = 3;
	} else {
		buf[0] = value >> 8;
		buf[1] = value >> 0;
		sz     = 2;
	}

	return tfa98xx_bulk_write(codec, reg, buf, sz);
}

static unsigned int tfa98xx_read_dsp(struct snd_soc_codec *codec, unsigned int reg)
{
	int ret;

	ret = snd_soc_write(codec, TFA98XX_CF_CONTROLS, (reg >> 15) & 0x0E);
	if (ret < 0)
		return ret;

	ret = snd_soc_write(codec, TFA98XX_CF_MAD, reg & 0xFFFF);
	if (ret < 0)
		return ret;

	return snd_soc_read(codec, TFA98XX_CF_MEM);
}

static int tfa98xx_reset(struct snd_soc_codec *codec)
{
	struct i2c_client *client = to_i2c_client(codec->dev);
	int ret;

	/* use the low level function to bypass the codec cache */
	ret = i2c_smbus_write_word_swapped(client, TFA98XX_SYS_CTRL, TFA98XX_SYS_CTRL_I2CR);
	if (ret < 0)
		return ret;

	/* apply the current setting after reset */
	codec->cache_sync = 1;
	ret = snd_soc_cache_sync(codec);
	if (ret < 0)
		return ret;

	return ret;
}

static int tfa98xx_reset_dsp(struct snd_soc_codec *codec)
{
	unsigned int sense4;
	int ret;

	/* temporarily disable clock gating when dsp reset */
	sense4 = snd_soc_read(codec, TFA98XX_CURRENTSENSE4);
	ret = snd_soc_write(codec, TFA98XX_CURRENTSENSE4,
			sense4 | TFA9897_CURRENTSENSE4_2);
	if (ret < 0)
		return ret;

	ret = snd_soc_update_bits(codec, TFA98XX_CF_CONTROLS,
			TFA98XX_CF_CONTROLS_RST_MSK, TFA98XX_CF_CONTROLS_RST);
	/* clock gating restore */
	snd_soc_write(codec, TFA98XX_CURRENTSENSE4, sense4);

	return ret;
}

static int tfa98xx_wait_clock(struct snd_soc_codec *codec)
{
	unsigned int status;
	int tries;

	for (tries = 10; tries > 0; tries--) {
		status = snd_soc_read(codec, TFA98XX_STATUSREG);
		if ((status & TFA98XX_STATUSREG_UP_MSK) == TFA98XX_STATUSREG_UP)
			break;
		mdelay(1);
	}
	if (tries == 0) {
		dev_err(codec->dev, "Fail to sync i2s clock on time(%x)\n", status);
		return -EBUSY;
	}

	return 0;
}

static int tfa98xx_power(struct snd_soc_codec *codec, bool on)
{
	int ret;

	ret = snd_soc_update_bits_locked(codec, TFA98XX_SYS_CTRL,
			TFA98XX_SYS_CTRL_PWDN_MSK, on ? 0 : TFA98XX_SYS_CTRL_PWDN);
	if (ret < 0)
		return ret;
	if (on)
		ret = tfa98xx_wait_clock(codec);
	return ret;
}

static int tfa98xx_mute(struct snd_soc_codec *codec, int mute)
{
	unsigned int status;
	int ret = 0, tries;

	switch (mute) {
	case TFA98XX_MUTE_OFF:
		ret = snd_soc_update_bits_locked(codec,
				TFA98XX_AUDIO_CTR, TFA98XX_AUDIO_CTR_CFSM_MSK, 0);
		if (ret < 0)
			return ret;
		ret = snd_soc_update_bits_locked(codec, TFA98XX_SYS_CTRL,
				TFA98XX_SYS_CTRL_DCA_MSK | TFA98XX_SYS_CTRL_AMPE_MSK,
				TFA98XX_SYS_CTRL_DCA | TFA98XX_SYS_CTRL_AMPE);
		if (ret < 0)
			return ret;
		break;
	case TFA98XX_MUTE_DIGITAL:
		ret = snd_soc_update_bits_locked(codec, TFA98XX_AUDIO_CTR,
				TFA98XX_AUDIO_CTR_CFSM_MSK, TFA98XX_AUDIO_CTR_CFSM);
		if (ret < 0)
			return ret;
		ret = snd_soc_update_bits_locked(codec, TFA98XX_SYS_CTRL,
				TFA98XX_SYS_CTRL_DCA_MSK | TFA98XX_SYS_CTRL_AMPE_MSK,
				TFA98XX_SYS_CTRL_AMPE);
		if (ret < 0)
			return ret;
		break;
	case TFA98XX_MUTE_AMPLIFIER:
		ret = snd_soc_update_bits_locked(codec,
				TFA98XX_AUDIO_CTR, TFA98XX_AUDIO_CTR_CFSM_MSK, 0);
		if (ret < 0)
			return ret;
		ret = snd_soc_update_bits_locked(codec, TFA98XX_SYS_CTRL,
				TFA98XX_SYS_CTRL_DCA_MSK | TFA98XX_SYS_CTRL_AMPE_MSK,
				0);
		if (ret < 0)
			return ret;

		/* wait for amplifier to stop switching */
		for (tries = 10; tries > 0; tries--) {
			status = snd_soc_read(codec, TFA98XX_STATUSREG);
			if (!(status & TFA98XX_STATUSREG_SWS_MSK))
				break;
			msleep(10);
		}
		if (tries == 0)
			dev_warn(codec->dev, "Fail to stop amplifier on time\n");
		break;
	}

	return ret;
}

static int tfa98xx_enable_otc(struct snd_soc_codec *codec, bool recalib)
{
	unsigned int mtp, status;
	int ret = 0, tries;

	mtp = snd_soc_read(codec, TFA98XX_MTP_SPKR_CAL);
	if (recalib || !(mtp & TFA98XX_MTP_SPKR_CAL_MTPOTC_MSK)) {
		ret = snd_soc_write(codec, TFA98XX_MTPKEY2_REG, 0x5A);
		if (ret < 0) {
			dev_err(codec->dev, "Fail to unlock key(%d)\n", ret);
			return ret;
		}

		mtp &= ~TFA98XX_MTP_SPKR_CAL_MTPEX_MSK;
		mtp |= TFA98XX_MTP_SPKR_CAL_MTPOTC_MSK;
		ret = snd_soc_write(codec, TFA98XX_MTP_SPKR_CAL, mtp);
		if (ret < 0) {
			dev_err(codec->dev, "Fail to update mtp(%d)\n", ret);
			return ret;
		}

		ret = snd_soc_update_bits(codec, TFA98XX_MTP_CTRL_REG3,
				TFA98XX_MTP_CTRL_REG3_CIMTP_MSK, TFA98XX_MTP_CTRL_REG3_CIMTP);
		if (ret < 0) {
			dev_err(codec->dev, "Fail to enable mtp copy(%d)\n", ret);
			return ret;
		}

		for (tries = 10; tries > 0; tries--) {
			status = snd_soc_read(codec, TFA98XX_STATUSREG);
			if (!(status & TFA98XX_STATUSREG_MTPB_MSK))
				break;
			msleep(100);
		}
		if (tries == 0) {
			dev_err(codec->dev, "Fail to copy mtp on time\n");
			return -EBUSY;
		}
	}

	return ret;
}

static int tfa98xx_download_patch(struct snd_soc_codec *codec,
				  const struct firmware *fw)
{
	int ret = -EINVAL;
	size_t i, sz;

	/* start from 6 to skip the patch header */
	for (i = 6; i < fw->size; i += sz) {
		sz  = fw->data[i++];
		sz += fw->data[i++] << 8;

		if (i + sz > fw->size) {
			dev_err(codec->dev,
				"Invalid patch format(%x, %x)\n", i, sz);
			return -EINVAL;
		}

		dev_dbg(codec->dev,
			"Download patch offset = %x, size = %x\n", i, sz);

		ret = snd_soc_bulk_write_raw(codec,
				fw->data[i], &fw->data[i + 1], sz - 1);
		if (ret < 0) {
			dev_err(codec->dev,
				"Fail to download patch(%x, %x, %d)\n", i, sz, ret);
			return ret;
		}
	}

	return ret;
}

static int tfa98xx_upload_file(struct snd_soc_codec *codec,
				int module_id, int param_id,
				void *data, size_t size)
{
	unsigned int status;
	int ret, tries;
	u8 buf[7];

	/* step 1: write the header */
	buf[0] = 0x00; /* CF_CONTROLS: req=0, int=0, aif=0, dmem=1(XMEM), rst_dsp=0 */
	buf[1] = 0x02;
	buf[2] = 0x00; /* CF_MAD: addr=1(ID) */
	buf[3] = 0x01;
	buf[4] = 0x00; /* CF_MEM */
	buf[5] = module_id;
	buf[6] = param_id;

	ret = snd_soc_bulk_write_raw(codec, TFA98XX_CF_CONTROLS, buf, 7);
	if (ret < 0) {
		dev_err(codec->dev, "Fail to write data header(%d)\n", ret);
		return ret;
	}

	/* step 2: wake up dsp and wait done */
	/* CF_CONTROLS: req=1, int=1, aif=0, dmem=1(XMEM), rst_dsp=0 */
	ret = snd_soc_write(codec, TFA98XX_CF_CONTROLS, 0x0112);
	if (ret < 0) {
		dev_err(codec->dev, "Fail to wake up dsp(%d)\n", ret);
		return ret;
	}

	for (tries = 10; tries > 0; tries--) {
		status = snd_soc_read(codec, TFA98XX_CF_STATUS);
		if ((status & TFA98XX_CF_STATUS_ACK_MSK) == 0x0100)
			break;
		mdelay(1);
	}
	if (tries == 0) {
		dev_err(codec->dev, "Fail to response on time\n");
		return -EBUSY;
	}

	/* step 3: check dsp result */
	buf[0] = 0x00; /* CF_CONTROLS: req=0, int=0, aif=0, dmem=1(XMEM), rst_dsp=0 */
	buf[1] = 0x02;
	buf[2] = 0x00; /* CF_MAD: addr=0(STATUS) */
	buf[3] = 0x00;

	ret = snd_soc_bulk_write_raw(codec, TFA98XX_CF_CONTROLS, buf, 4);
	if (ret < 0) {
		dev_err(codec->dev, "Fail to write status header(%d)\n", ret);
		return ret;
	}

	status = snd_soc_read(codec, TFA98XX_CF_MEM);
	if (status != 0) {
		dev_err(codec->dev, "Fail to upload file(%d)\n", status);
		return -EINVAL;
	}

	/* step 4: read the data */
	ret = snd_soc_write(codec, TFA98XX_CF_MAD, 0x0002);
	if (ret < 0) {
		dev_err(codec->dev, "Fail to write memory address(%d)\n", ret);
		return ret;
	}

	ret = tfa98xx_bulk_read(codec, TFA98XX_CF_MEM, data, size);
	if (ret < 0) {
		dev_err(codec->dev, "Fail to read data(%d)\n", ret);
		return ret;
	}

	return ret;
}

static int tfa98xx_download_file(struct snd_soc_codec *codec,
				 int module_id, int param_id,
				 const void *data, size_t size)
{
	unsigned int status;
	int ret, tries;
	u8 buf[7];

	/* step 1: write the header */
	buf[0] = 0x00; /* CF_CONTROLS: req=0, int=0, aif=0, dmem=1(XMEM), rst_dsp=0 */
	buf[1] = 0x02;
	buf[2] = 0x00; /* CF_MAD: addr=1(ID) */
	buf[3] = 0x01;
	buf[4] = 0x00; /* CF_MEM */
	buf[5] = module_id;
	buf[6] = param_id;

	ret = snd_soc_bulk_write_raw(codec, TFA98XX_CF_CONTROLS, buf, 7);
	if (ret < 0) {
		dev_err(codec->dev, "Fail to write data header(%d)\n", ret);
		return ret;
	}

	/* step 2: write the data */
	ret = snd_soc_bulk_write_raw(codec, TFA98XX_CF_MEM, data, size);
	if (ret < 0) {
		dev_err(codec->dev, "Fail to write data(%d)\n", ret);
		return ret;
	}

	/* step 3: wake up dsp and wait done */
	/* CF_CONTROLS: req=1, int=1, aif=0, dmem=1(XMEM), rst_dsp=0 */
	ret = snd_soc_write(codec, TFA98XX_CF_CONTROLS, 0x0112);
	if (ret < 0) {
		dev_err(codec->dev, "Fail to wake up dsp(%d)\n", ret);
		return ret;
	}

	for (tries = 10; tries > 0; tries--) {
		status = snd_soc_read(codec, TFA98XX_CF_STATUS);
		if ((status & TFA98XX_CF_STATUS_ACK_MSK) == 0x0100)
			break;
		mdelay(1);
	}
	if (tries == 0) {
		dev_err(codec->dev, "Fail to response on time\n");
		return -EBUSY;
	}

	/* step 4: check dsp result */
	buf[0] = 0x00; /* CF_CONTROLS: req=0, int=0, aif=0, dmem=1(XMEM), rst_dsp=0 */
	buf[1] = 0x02;
	buf[2] = 0x00; /* CF_MAD: addr=0(STATUS) */
	buf[3] = 0x00;

	ret = snd_soc_bulk_write_raw(codec, TFA98XX_CF_CONTROLS, buf, 4);
	if (ret < 0) {
		dev_err(codec->dev, "Fail to write status header(%d)\n", ret);
		return ret;
	}

	status = snd_soc_read(codec, TFA98XX_CF_MEM);
	if (status != 0) {
		dev_err(codec->dev, "Fail to download file(%d)\n", status);
		return -EINVAL;
	}

	return ret;
}

static int tfa98xx_download_and_verify_file(struct snd_soc_codec *codec,
					    int module_id, int param_id,
					    const void *data, size_t size)
{
	u8 buf[size];
	int ret;

	ret = tfa98xx_download_file(codec, module_id, param_id, data, size);
	if (ret < 0)
		return ret;
	ret = tfa98xx_upload_file(codec, module_id, param_id, buf, size);
	if (ret < 0)
		return ret;
	if (memcmp(data, buf, size) != 0) {
		dev_err(codec->dev, "Write then read mismatch:\n");
		print_hex_dump(KERN_ERR, "WR ",
			DUMP_PREFIX_ADDRESS, 16, 1, data, size, true);
		print_hex_dump(KERN_ERR, "RD ",
			DUMP_PREFIX_ADDRESS, 16, 1, buf, size, true);
		return -EINVAL;
	}

	return ret;
}

static void tfa98xx_download(struct work_struct *work)
{
	struct tfa98xx_priv *tfa98xx;
	struct snd_soc_codec *codec;
	struct delayed_work *dwork;
	unsigned int mtp;
	int ret = 0, id, tries;

	dwork = to_delayed_work(work);
	tfa98xx = container_of(dwork, struct tfa98xx_priv, download_work);
	codec = tfa98xx->codec;

	mutex_lock(&tfa98xx->fw_lock);

	/* wait the clock stable */
	if (codec->dapm.bias_level == SND_SOC_BIAS_OFF)
		goto unlock; /* impossible to get the clock */

	ret = tfa98xx_wait_clock(codec);
	if (ret < 0)
		goto unlock;

	ret = tfa98xx_enable_otc(codec, tfa98xx->recalib);
	if (ret < 0)
		goto unlock;
	tfa98xx->recalib = false;

	ret = tfa98xx_mute(codec, TFA98XX_MUTE_DIGITAL);
	if (ret < 0)
		goto unlock;

	for (id = 0; id < TFA98XX_FW_NUMBER; id++) {
		if (tfa98xx->fw[id] == NULL)
			goto unmute;
		if (!tfa98xx->fw_chg[id])
			continue;

		dev_info(codec->dev,
			"Download firmware %s\n", tfa98xx->fw_name[id]);

		switch (id) {
		case TFA98XX_FW_BOOT:
			ret = tfa98xx_reset_dsp(codec);
			if (ret < 0)
				goto unmute;
			ret = tfa98xx_wait_clock(codec);
			if (ret < 0)
				goto unmute;
			ret = tfa98xx_download_patch(codec, tfa98xx->fw[id]);
			if (ret < 0)
				goto unmute;
			/* reload rom patch */
			tfa98xx->fw_chg[TFA98XX_FW_ROM] = true;
			break;
		case TFA98XX_FW_ROM:
			ret = tfa98xx_download_patch(codec, tfa98xx->fw[id]);
			if (ret < 0)
				goto unmute;
			/* reload all setting */
			tfa98xx->fw_chg[TFA98XX_FW_SPEAKER]   = true;
			tfa98xx->fw_chg[TFA98XX_FW_CONFIG]    = true;
			tfa98xx->fw_chg[TFA98XX_FW_PRESET]    = true;
			tfa98xx->fw_chg[TFA98XX_FW_EQUALIZER] = true;
			break;
		case TFA98XX_FW_SPEAKER:
			ret = tfa98xx_download_and_verify_file(codec,
						    TFA98XX_MODULE_SPEAKERBOOST,
						    TFA98XX_PARAM_SET_LSMODEL,
						    tfa98xx->fw[id]->data,
						    tfa98xx->fw[id]->size);
			if (ret < 0)
				goto unmute;
			break;
		case TFA98XX_FW_CONFIG:
			ret = tfa98xx_download_and_verify_file(codec,
						    TFA98XX_MODULE_SPEAKERBOOST,
						    TFA98XX_PARAM_SET_CONFIG,
						    tfa98xx->fw[id]->data,
						    tfa98xx->fw[id]->size);
			if (ret < 0)
				goto unmute;
			break;
		case TFA98XX_FW_PRESET:
			ret = tfa98xx_download_and_verify_file(codec,
						    TFA98XX_MODULE_SPEAKERBOOST,
						    TFA98XX_PARAM_SET_PRESET,
						    tfa98xx->fw[id]->data,
						    tfa98xx->fw[id]->size);
			if (ret < 0)
				goto unmute;
			break;
		case TFA98XX_FW_EQUALIZER:
			ret = tfa98xx_download_and_verify_file(codec,
						    TFA98XX_MODULE_BIQUADFILTERBANK,
						    0,
						    tfa98xx->fw[id]->data,
						    tfa98xx->fw[id]->size);
			if (ret < 0)
				goto unmute;
			break;
		}

		/* done, clear dirty flag */
		tfa98xx->fw_chg[id] = false;
	}

	/* signal dsp to load the setting */
	mtp = snd_soc_read(codec, TFA98XX_MTP_SPKR_CAL);
	if (!(mtp & TFA98XX_MTP_SPKR_CAL_MTPEX_MSK))
		dev_info(codec->dev, "Start one time calibration\n");
	else
		dev_info(codec->dev, "Load the calibration value from mtp\n");

	snd_soc_update_bits_locked(codec, TFA98XX_SYS_CTRL,
		TFA98XX_SYS_CTRL_SBSL_MSK, TFA98XX_SYS_CTRL_SBSL);

	for (tries = 10; tries > 0; tries--) {
		mtp = snd_soc_read(codec, TFA98XX_MTP_SPKR_CAL);
		if (mtp & TFA98XX_MTP_SPKR_CAL_MTPEX_MSK)
			break;
		msleep(100);
	}

	if (tries == 0)
		dev_warn(codec->dev, "Fail to calibrate on time\n");
	else
		dev_info(codec->dev, "Finish one time calibration\n");

unmute:
	tfa98xx_mute(codec, TFA98XX_MUTE_OFF);
unlock:
	mutex_unlock(&tfa98xx->fw_lock);

	/* retry in a late time if fail */
	if (ret < 0) {
		queue_delayed_work(tfa98xx->workqueue,
			&tfa98xx->download_work, msecs_to_jiffies(10));
	}
}

static bool tfa98xx_start_download(struct tfa98xx_priv *tfa98xx, bool force)
{
	bool sched = force;
	int id;

	mutex_lock(&tfa98xx->fw_lock);
	if (force) { /* re-download all firmware */
		for (id = 0; id < TFA98XX_FW_NUMBER; id++)
			tfa98xx->fw_chg[id] = true;
	} else { /* check the pending change exist */
		for (id = 0; id < TFA98XX_FW_NUMBER; id++) {
			if (tfa98xx->fw_chg[id]) {
				sched = true;
				break;
			}
		}
	}
	mutex_unlock(&tfa98xx->fw_lock);

	if (sched)
		queue_delayed_work(tfa98xx->workqueue, &tfa98xx->download_work, 0);
	return sched;
}

static void tfa98xx_stop_download(struct tfa98xx_priv *tfa98xx)
{
	cancel_delayed_work_sync(&tfa98xx->download_work);
}

static void tfa98xx_start_monitor(struct tfa98xx_priv *tfa98xx)
{
	queue_delayed_work(tfa98xx->workqueue,
		&tfa98xx->monitor_work, msecs_to_jiffies(5000));
}

static void tfa98xx_stop_monitor(struct tfa98xx_priv *tfa98xx)
{
	cancel_delayed_work_sync(&tfa98xx->monitor_work);
}

static int tfa98xx_check_error(struct snd_soc_codec *codec)
{
	unsigned int status;

	status = snd_soc_read(codec, TFA98XX_STATUSREG);
	if (status & TFA98XX_STATUSREG_ERR2_MSK)
		return 2;
	else if (status & TFA98XX_STATUSREG_ERR1_MSK)
		return 1;

	status = tfa98xx_read_dsp(codec, 0x666);
	if (status == 0x7FFFFF)
		return 2;

	return 0;
}

static void tfa98xx_monitor(struct work_struct *work)
{
	struct tfa98xx_priv *tfa98xx;
	struct snd_soc_codec *codec;
	struct delayed_work *dwork;

	dwork = to_delayed_work(work);
	tfa98xx = container_of(dwork, struct tfa98xx_priv, monitor_work);
	codec = tfa98xx->codec;

	switch (tfa98xx_check_error(codec)) {
	case 2:
		dev_err(codec->dev, "Restart due to dsp crash\n");
		tfa98xx->dsp_crash = true; /* save crash info */
		tfa98xx->pilot_tone = tfa98xx_read_dsp(codec, 0x1029A);
		tfa98xx_reset(codec);
		tfa98xx_start_download(tfa98xx, true);
		break;
	case 1:
		dev_err(codec->dev, "Repower due to over condition\n");
		tfa98xx_power(codec, false);
		usleep_range(5000, 5000);
		tfa98xx_power(codec, true);
		break;
	}

	tfa98xx_start_monitor(tfa98xx);
}

static ssize_t tfa98xx_dsp_crash_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct i2c_client *client = to_i2c_client(dev);
	struct tfa98xx_priv *tfa98xx = i2c_get_clientdata(client);

	return sprintf(buf, "%d\n", tfa98xx->dsp_crash);
}

static ssize_t tfa98xx_crash_store(struct device *dev,
	struct device_attribute *attr, const char *buf, size_t count)
{
	struct i2c_client *client = to_i2c_client(dev);
	struct tfa98xx_priv *tfa98xx = i2c_get_clientdata(client);
	unsigned long val;
	int ret;

	ret = strict_strtoul(buf, 0, &val);
	if (ret < 0)
		return ret;
	tfa98xx->dsp_crash = (val != 0);

	return count;
}
static DEVICE_ATTR(dsp_crash, 0664, tfa98xx_dsp_crash_show, tfa98xx_crash_store);


static ssize_t tfa98xx_pilot_tone_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct i2c_client *client = to_i2c_client(dev);
	struct tfa98xx_priv *tfa98xx = i2c_get_clientdata(client);

	return sprintf(buf, "0x%06X\n", tfa98xx->pilot_tone);
}
static DEVICE_ATTR(pilot_tone, 0444, tfa98xx_pilot_tone_show, NULL);

static const u8 fw_data_tfa9890_config[] = {
	0x0f, 0xcc, 0xcd, 0x01, 0xf6, 0x66, 0x00, 0x7b, 0x33, 0x00, 0x00, 0x14, 0x00, 0x00, 0x02, 0x1a,
	0xe6, 0x40, 0x1b, 0x40, 0xd4, 0x1c, 0x59, 0xda, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x4b, 0x00, 0x01, 0x4b, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xfa, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x01, 0x00, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x47, 0x0c, 0xcc, 0xcd, 0x00, 0x33,
	0x33, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x01, 0x01, 0x80, 0x00,
	0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x50, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x19, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x01, 0x47, 0xae, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x19, 0x99, 0x9a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x30,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x18, 0xec, 0x00, 0x00, 0x00, 0x03, 0xd7, 0x01, 0x00, 0x00, 0x20,
	0x00, 0x00, 0x01, 0x00, 0x00
};
static struct firmware fw_tfa9890_config = {
	.size = sizeof(fw_data_tfa9890_config),
	.data = fw_data_tfa9890_config,
	.pages = NULL,
	.priv = NULL,
};

static const u8 fw_data_tfa9890_boot_patch[] = {
	0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x08, 0x00, 0x70, 0x00, 0x07, 0x81, 0x00, 0x00, 0x00, 0x01
};
static struct firmware fw_tfa9890_boot_patch = {
	.size = sizeof(fw_data_tfa9890_boot_patch),
	.data = fw_data_tfa9890_boot_patch,
	.pages = NULL,
	.priv = NULL,
};

static const u8 fw_data_tfa9890_left_speaker[] = {
	0xff, 0xff, 0x0a, 0xff, 0xfe, 0xfb, 0x00, 0x00, 0x40, 0xff, 0xfd, 0xb1, 0xff, 0xff, 0xa7, 0xff,
	0xfe, 0x81, 0xff, 0xff, 0xaf, 0xff, 0xfd, 0x9a, 0xff, 0xfc, 0xc2, 0xff, 0xfd, 0xe5, 0xff, 0xfc,
	0x90, 0xff, 0xfe, 0xee, 0xff, 0xfe, 0xab, 0xff, 0xff, 0x23, 0xff, 0xfe, 0x81, 0xff, 0xfe, 0x09,
	0xff, 0xfe, 0xce, 0xff, 0xff, 0x84, 0xff, 0xff, 0x02, 0xff, 0xfe, 0xa6, 0xff, 0xfe, 0x8a, 0xff,
	0xfe, 0xdd, 0xff, 0xfe, 0x7d, 0xff, 0xfe, 0x10, 0xff, 0xfe, 0xee, 0xff, 0xfd, 0xb8, 0xff, 0xff,
	0x14, 0xff, 0xfe, 0x1d, 0xff, 0xff, 0x7d, 0xff, 0xfd, 0x8d, 0xff, 0xff, 0x29, 0xff, 0xfe, 0x04,
	0xff, 0xfd, 0xca, 0xff, 0xfe, 0x6e, 0xff, 0xfc, 0xdb, 0xff, 0xff, 0x2d, 0xff, 0xfd, 0x82, 0xff,
	0xfe, 0x96, 0xff, 0xfe, 0xad, 0xff, 0xff, 0x85, 0xff, 0xfd, 0x21, 0xff, 0xff, 0x04, 0xff, 0xfd,
	0x5d, 0xff, 0xfd, 0xee, 0xff, 0xfd, 0x36, 0xff, 0xfb, 0x05, 0xff, 0xfd, 0x05, 0xff, 0xfe, 0x4c,
	0xff, 0xfc, 0x46, 0xff, 0xfc, 0xc8, 0x00, 0x00, 0x7b, 0xff, 0xfc, 0x65, 0x00, 0x00, 0x5f, 0xff,
	0xf9, 0xa6, 0xff, 0xff, 0x5c, 0xff, 0xfc, 0x66, 0xff, 0xff, 0x7d, 0xff, 0xfc, 0xe3, 0xff, 0xfe,
	0xe2, 0xff, 0xfb, 0x72, 0xff, 0xfd, 0x4b, 0xff, 0xfa, 0x7b, 0xff, 0xfb, 0xc3, 0xff, 0xfc, 0xa0,
	0xff, 0xfb, 0xab, 0xff, 0xfd, 0x58, 0xff, 0xfd, 0x30, 0xff, 0xfc, 0xba, 0xff, 0xfe, 0xf2, 0xff,
	0xfa, 0xd2, 0xff, 0xfc, 0x30, 0xff, 0xfb, 0x67, 0xff, 0xfc, 0xaf, 0xff, 0xfb, 0xef, 0x00, 0x00,
	0xaa, 0xff, 0xf9, 0x56, 0xff, 0xfd, 0xf9, 0xff, 0xf8, 0x46, 0xff, 0xfc, 0x86, 0xff, 0xfd, 0x69,
	0x00, 0x02, 0x06, 0xff, 0xf9, 0xb8, 0xff, 0xfc, 0xbf, 0xff, 0xf7, 0x87, 0xff, 0xfc, 0xc3, 0x00,
	0x01, 0x40, 0xff, 0xf8, 0x6c, 0xff, 0xff, 0xe1, 0xff, 0xf6, 0xe6, 0xff, 0xfe, 0x51, 0xff, 0xf8,
	0x76, 0xff, 0xfe, 0xb2, 0xff, 0xfe, 0x56, 0xff, 0xfa, 0x2e, 0xff, 0xf9, 0xec, 0xff, 0xfa, 0x84,
	0xff, 0xfe, 0x92, 0xff, 0xf9, 0x2c, 0xff, 0xfb, 0x3d, 0xff, 0xfa, 0x28, 0xff, 0xfb, 0x65, 0x00,
	0x06, 0x6a, 0xff, 0xff, 0x05, 0x00, 0x0f, 0x7c, 0xff, 0xe6, 0x2f, 0xff, 0xfa, 0xd0, 0xff, 0xbf,
	0xa9, 0x00, 0x00, 0x38, 0xff, 0xc2, 0x58, 0x00, 0x47, 0x94, 0x00, 0x10, 0x4d, 0x00, 0xad, 0x56,
	0x00, 0x1a, 0x34, 0x00, 0x80, 0x70, 0xfe, 0xdf, 0xc2, 0x07, 0xb9, 0xf9, 0x00, 0x86, 0x5b, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x4c, 0xcc, 0xcd, 0x63, 0xd7, 0x0a, 0x20, 0x00, 0x00, 0x20, 0x00, 0x00, 0x20,
	0x00, 0x00, 0x18, 0x51, 0xec, 0x00, 0x03, 0x64, 0x00, 0x03, 0x63, 0x04, 0x00, 0x00, 0x00, 0x40,
	0x00, 0x19, 0x00, 0x00, 0x00, 0x6c, 0x22
};
static struct firmware fw_tfa9890_left_speaker = {
	.size = sizeof(fw_data_tfa9890_left_speaker),
	.data = fw_data_tfa9890_left_speaker,
	.pages = NULL,
	.priv = NULL,
};

static const u8 fw_data_tfa9890_left_music_eq[] = {
	0x00, 0x00, 0x01, 0xc2, 0x53, 0x98, 0x7d, 0xa1, 0x60, 0x3e, 0xd3, 0x70, 0x82, 0x59, 0x1c, 0x3e,
	0xd3, 0x70, 0x00, 0x00, 0x01, 0xc2, 0x53, 0x98, 0x7d, 0xa1, 0x60, 0x3e, 0xd3, 0x70, 0x82, 0x59,
	0x1c, 0x3e, 0xd3, 0x70, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00
};
static struct firmware fw_tfa9890_left_music_eq = {
	.size = sizeof(fw_data_tfa9890_left_music_eq),
	.data = fw_data_tfa9890_left_music_eq,
	.pages = NULL,
	.priv = NULL,
};

static const u8 fw_data_tfa9890_left_music_preset[] = {
	0x00, 0x00, 0x01, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x2c, 0x01, 0x47, 0xae, 0x00, 0x2b, 0xb0, 0x00, 0x14, 0x7b, 0x00, 0xa3,
	0xd7, 0x01, 0x00, 0x00, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00,
	0x02, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0xcd, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x48, 0x01, 0x00, 0x00, 0x00, 0x01, 0x48, 0x00, 0x01, 0x48, 0x08, 0x00, 0x00, 0x07, 0xc2,
	0x8f, 0x00, 0x07, 0xae, 0x00, 0x00, 0x14
};
static struct firmware fw_tfa9890_left_music_preset = {
	.size = sizeof(fw_data_tfa9890_left_music_preset),
	.data = fw_data_tfa9890_left_music_preset,
	.pages = NULL,
	.priv = NULL,
};

static const u8 fw_data_tfa9890_right_speaker[] = {
	0xff, 0xff, 0x4c, 0xff, 0xfe, 0x6a, 0xff, 0xff, 0xd2, 0xff, 0xfe, 0x7c, 0xff, 0xfe, 0x04, 0xff,
	0xfe, 0x73, 0xff, 0xfd, 0x36, 0xff, 0xfe, 0x73, 0xff, 0xfd, 0xea, 0xff, 0xfd, 0xfc, 0xff, 0xfe,
	0xe8, 0xff, 0xfd, 0x99, 0xff, 0xff, 0xaa, 0xff, 0xfe, 0x22, 0xff, 0xff, 0x0f, 0xff, 0xfe, 0x3a,
	0xff, 0xfe, 0xef, 0xff, 0xfe, 0x8a, 0xff, 0xff, 0x08, 0xff, 0xfd, 0x71, 0xff, 0xfe, 0xb1, 0xff,
	0xff, 0x33, 0xff, 0xfe, 0x8b, 0xff, 0xfc, 0x52, 0xff, 0xfe, 0x32, 0xff, 0xfe, 0x15, 0xff, 0xfd,
	0x89, 0xff, 0xfd, 0xe0, 0xff, 0xfe, 0xbd, 0xff, 0xff, 0x0e, 0xff, 0xfd, 0x94, 0xff, 0xff, 0x43,
	0xff, 0xfc, 0x97, 0xff, 0xff, 0x2b, 0xff, 0xfe, 0x85, 0xff, 0xfe, 0x27, 0xff, 0xfc, 0xe2, 0xff,
	0xfe, 0xc8, 0xff, 0xfc, 0xcf, 0xff, 0xfe, 0x54, 0xff, 0xfc, 0x44, 0xff, 0xfc, 0x51, 0xff, 0xfd,
	0x4d, 0xff, 0xfd, 0x8d, 0xff, 0xfc, 0x5b, 0xff, 0xfe, 0x6b, 0xff, 0xfd, 0x43, 0xff, 0xfe, 0xef,
	0xff, 0xfe, 0x25, 0xff, 0xfd, 0x9f, 0xff, 0xfd, 0xf5, 0xff, 0xfc, 0x57, 0xff, 0xfb, 0x67, 0xff,
	0xfd, 0xe8, 0xff, 0xfe, 0x13, 0xff, 0xfd, 0xaa, 0xff, 0xfc, 0xae, 0xff, 0xfc, 0xa0, 0xff, 0xfd,
	0x1d, 0xff, 0xfb, 0xb3, 0xff, 0xfc, 0x65, 0xff, 0xfd, 0xe9, 0xff, 0xfd, 0xd8, 0xff, 0xfb, 0x23,
	0xff, 0xfe, 0x28, 0xff, 0xf9, 0xa9, 0xff, 0xff, 0xfc, 0xff, 0xfa, 0x51, 0xff, 0xfd, 0xe7, 0xff,
	0xfa, 0x92, 0xff, 0xfe, 0x13, 0xff, 0xf8, 0xce, 0x00, 0x00, 0x24, 0xff, 0xf8, 0x34, 0xff, 0xfe,
	0xa1, 0xff, 0xfb, 0x1f, 0xff, 0xff, 0x28, 0xff, 0xf8, 0xd1, 0xff, 0xfc, 0xe5, 0xff, 0xf9, 0xf6,
	0xff, 0xfd, 0xbe, 0xff, 0xf9, 0xd9, 0xff, 0xfc, 0x64, 0xff, 0xff, 0x49, 0xff, 0xf7, 0xbe, 0xff,
	0xfc, 0x59, 0xff, 0xfa, 0xbb, 0xff, 0xfc, 0x19, 0xff, 0xfa, 0x62, 0xff, 0xfc, 0x48, 0xff, 0xfa,
	0xd6, 0xff, 0xfe, 0x51, 0xff, 0xf5, 0xec, 0x00, 0x00, 0xa0, 0xff, 0xf7, 0xa4, 0x00, 0x01, 0x6e,
	0xff, 0xf1, 0x33, 0x00, 0x04, 0xfc, 0xff, 0xef, 0x7b, 0x00, 0x0c, 0x12, 0xff, 0xf0, 0x61, 0x00,
	0x13, 0x57, 0xff, 0xf2, 0xa3, 0x00, 0x0b, 0xff, 0xff, 0xdc, 0x83, 0xff, 0xfd, 0x56, 0xff, 0xcc,
	0x37, 0xff, 0xee, 0xbd, 0xff, 0xe9, 0x36, 0x00, 0x27, 0x82, 0x00, 0x45, 0x41, 0x00, 0x6c, 0x58,
	0x00, 0x58, 0x15, 0x00, 0x00, 0xbf, 0xff, 0xc8, 0x43, 0x07, 0x7a, 0x5d, 0xff, 0xfa, 0xec, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x4c, 0xcc, 0xcd, 0x66, 0x66, 0x66, 0x20, 0x00, 0x00, 0x20, 0x00, 0x00, 0x20,
	0x00, 0x00, 0x19, 0x99, 0x9a, 0x00, 0x03, 0x64, 0x00, 0x03, 0x65, 0x04, 0x00, 0x00, 0x00, 0x40,
	0x00, 0x19, 0x00, 0x00, 0x00, 0x6c, 0x22
};
static struct firmware fw_tfa9890_right_speaker = {
	.size = sizeof(fw_data_tfa9890_right_speaker),
	.data = fw_data_tfa9890_right_speaker,
	.pages = NULL,
	.priv = NULL,
};

static const u8 fw_data_tfa9890_right_music_eq[] = {
	0x00, 0x00, 0x01, 0xc2, 0x53, 0x98, 0x7d, 0xa1, 0x60, 0x3e, 0xd3, 0x70, 0x82, 0x59, 0x1c, 0x3e,
	0xd3, 0x70, 0x00, 0x00, 0x01, 0xc2, 0x53, 0x98, 0x7d, 0xa1, 0x60, 0x3e, 0xd3, 0x70, 0x82, 0x59,
	0x1c, 0x3e, 0xd3, 0x70, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00
};
static struct firmware fw_tfa9890_right_music_eq = {
	.size = sizeof(fw_data_tfa9890_right_music_eq),
	.data = fw_data_tfa9890_right_music_eq,
	.pages = NULL,
	.priv = NULL,
};

static const u8 fw_data_tfa9890_right_music_preset[] = {
	0x00, 0x00, 0x01, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x2c, 0x01, 0x47, 0xae, 0x00, 0x2b, 0xb0, 0x00, 0x14, 0x7b, 0x01, 0x47,
	0xae, 0x01, 0x00, 0x00, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x02, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0xcd, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x48, 0x01, 0x00, 0x00, 0x00, 0x01, 0x48, 0x00, 0x01, 0x48, 0x08, 0x00, 0x00, 0x07, 0xc2,
	0x8f, 0x00, 0x07, 0xae, 0x00, 0x00, 0x14
};
static struct firmware fw_tfa9890_right_music_preset = {
	.size = sizeof(fw_data_tfa9890_right_music_preset),
	.data = fw_data_tfa9890_right_music_preset,
	.pages = NULL,
	.priv = NULL,
};

static const u8 fw_data_tfa9890_rom_patch[] = {
	0x80, 0x20, 0xc6, 0x00, 0x00, 0x31, 0x03, 0x00, 0x70, 0x00, 0x01, 0xfb, 0x00, 0x71, 0x40, 0x00,
	0x61, 0x48, 0x7d, 0x2e, 0x3a, 0x9a, 0x00, 0xca, 0x69, 0x7c, 0x55, 0xf7, 0x6a, 0x7b, 0x55, 0x75,
	0x6c, 0x3d, 0x54, 0x79, 0x3b, 0x80, 0x18, 0x98, 0xb5, 0x00, 0x62, 0x4a, 0x9b, 0xa2, 0xd4, 0xb5,
	0x61, 0x81, 0x78, 0x0b, 0xa2, 0x1a, 0xf8, 0x4a, 0x3b, 0x46, 0x40, 0x10, 0x6a, 0x3d, 0xd4, 0xfc,
	0x6a, 0x1b, 0x54, 0xbc, 0x3b, 0x80, 0x15, 0x41, 0xb5, 0x00, 0x42, 0x88, 0xb5, 0x00, 0x54, 0x3b,
	0x7c, 0x44, 0xd4, 0xb8, 0x61, 0xc0, 0x42, 0x91, 0x6a, 0xbe, 0xd4, 0xb6, 0x3b, 0x80, 0x02, 0x4b,
	0x9b, 0xc3, 0x62, 0x09, 0x6a, 0xdd, 0xd4, 0x3d, 0x3a, 0x90, 0x00, 0x25, 0x61, 0xcc, 0x42, 0x80,
	0x6a, 0xbe, 0xd4, 0xb9, 0x3b, 0x80, 0x02, 0x4b, 0x9b, 0xc3, 0x62, 0x09, 0x9b, 0xa0, 0xd4, 0x3b,
	0x3a, 0x88, 0x00, 0x96, 0x66, 0x04, 0x45, 0x0a, 0x79, 0x40, 0xc3, 0x80, 0x3a, 0x89, 0xff, 0x6b,
	0x80, 0x18, 0x54, 0x39, 0xb5, 0x00, 0x54, 0xfb, 0x3b, 0x80, 0x04, 0x39, 0x80, 0xd4, 0x74, 0x55,
	0x7f, 0x4e, 0x54, 0xbb, 0x6a, 0x5c, 0xc2, 0x88, 0x3b, 0x80, 0x02, 0x9c, 0x3c, 0xc8, 0xff, 0xd5,
	0x7f, 0x4e, 0x54, 0x3b, 0xb5, 0x00, 0x43, 0x00, 0x38, 0x12, 0x00, 0xcf, 0x38, 0x20, 0x00, 0xa2,
	0xb5, 0x00, 0x76, 0x08, 0x3b, 0x80, 0x02, 0xcd, 0x9b, 0xa2, 0x74, 0x55, 0x7f, 0x4e, 0x54, 0x3b,
	0xb5, 0x00, 0x43, 0x00, 0x3a, 0x90, 0x00, 0xc8, 0x6a, 0xbd, 0xf4, 0x55, 0xb5, 0x00, 0x62, 0x09,
	0x30, 0xb0, 0x02, 0x7e, 0x30, 0x50, 0x00, 0x80, 0x3b, 0x80, 0x04, 0x55, 0x30, 0xa0, 0x0e, 0x00,
	0x7f, 0x4e, 0x54, 0x3d, 0xb5, 0x00, 0x43, 0x00, 0x90, 0xdb, 0x54, 0xbb, 0x61, 0x44, 0x7e, 0x9c,
	0xa2, 0x17, 0x7e, 0x9c, 0x3b, 0x43, 0x40, 0xa6, 0xfb, 0x00, 0x71, 0x40, 0x3e, 0x3a, 0x89, 0xff,
	0x36, 0xb5, 0x00, 0x54, 0xfe, 0x38, 0x12, 0x02, 0x7e, 0x30, 0x60, 0x00, 0x80, 0x30, 0x80, 0x0e,
	0x00, 0x30, 0xa0, 0x01, 0x80, 0x3b, 0x80, 0x02, 0xb8, 0xb5, 0x00, 0x61, 0x46, 0x30, 0x80, 0x01,
	0x00, 0x30, 0x50, 0x01, 0x00, 0x30, 0x70, 0x00, 0x80, 0x3b, 0x80, 0x00, 0x48, 0x38, 0x0c, 0x02,
	0xff, 0x30, 0x90, 0x01, 0x80, 0x38, 0x0a, 0x20, 0x01, 0x20, 0x80, 0x40, 0x52, 0x30, 0x80, 0x01,
	0x00, 0xb5, 0x00, 0x42, 0x01, 0xb5, 0x00, 0x43, 0x08, 0xd4, 0xc8, 0x42, 0x01, 0x60, 0x24, 0xfe,
	0x9c, 0x30, 0x90, 0x01, 0x00, 0x30, 0x50, 0x00, 0x80, 0x30, 0xa0, 0x20, 0x3e, 0x3b, 0x80, 0x04,
	0x0a, 0x30, 0x80, 0x01, 0x80, 0x30, 0x80, 0x01, 0x00, 0x30, 0x50, 0x00, 0x80, 0x3b, 0x80, 0x02,
	0x5f, 0x30, 0x90, 0x01, 0x00, 0xb5, 0x00, 0x54, 0xb5, 0x3a, 0x89, 0x00, 0x87, 0xb5, 0x00, 0x42,
	0x88, 0x82, 0x14, 0x7e, 0x9c, 0x3b, 0x65, 0x40, 0x64, 0x34, 0x00, 0x0e, 0x8d, 0x3b, 0x00, 0x40,
	0xa6, 0x34, 0x00, 0x0e, 0x8e, 0x30, 0x80, 0x01, 0x00, 0x30, 0xa0, 0x01, 0x80, 0x30, 0x50, 0x00,
	0x40, 0x3b, 0x80, 0x03, 0x35, 0x3a, 0x88, 0x00, 0x01, 0x38, 0x08, 0x20, 0x00, 0x30, 0x90, 0x01,
	0x00, 0x30, 0x60, 0x00, 0x3f, 0x20, 0x3f, 0x40, 0x74, 0x38, 0x0a, 0x20, 0x00, 0x8b, 0xe0, 0x7b,
	0x00, 0xb5, 0x00, 0x40, 0x09, 0xa2, 0x10, 0x7e, 0x9c, 0x3b, 0x67, 0x40, 0x73, 0x80, 0x80, 0x64,
	0x07, 0x90, 0xfc, 0xfe, 0x9c, 0xb5, 0x00, 0x7e, 0x9c, 0x69, 0x3f, 0xe1, 0x10, 0x30, 0x90, 0x01,
	0x80, 0xb5, 0x00, 0x76, 0x48, 0x3b, 0x80, 0x02, 0x58, 0xb0, 0xda, 0x62, 0x09, 0x3a, 0x20, 0xff,
	0xff, 0xb5, 0x00, 0x7a, 0x40, 0xfb, 0x00, 0x71, 0x40, 0x7c, 0x30, 0x80, 0x01, 0x00, 0x20, 0x3f,
	0x40, 0x81, 0x30, 0x90, 0x01, 0x80, 0x80, 0x68, 0x40, 0x09, 0xb2, 0x08, 0x7e, 0x9c, 0xa0, 0x6c,
	0x40, 0x09, 0xb5, 0x00, 0x76, 0x40, 0x38, 0x6c, 0x20, 0x00, 0x3c, 0xd8, 0x06, 0x04, 0x20, 0x17,
	0x40, 0x88, 0x9b, 0xa4, 0xc3, 0x08, 0xa6, 0xba, 0xfe, 0x9c, 0xb4, 0x4a, 0xfe, 0x9c, 0x9b, 0xc7,
	0xe1, 0x76, 0xb5, 0x00, 0x61, 0x03, 0xd0, 0x24, 0x74, 0x12, 0x30, 0xa0, 0x0e, 0x8f, 0xa4, 0x03,
	0x62, 0x4a, 0x38, 0x0a, 0x0e, 0x83, 0x38, 0x0c, 0x0e, 0x82, 0x3b, 0x80, 0x02, 0x2b, 0x9b, 0xe0,
	0xd0, 0x52, 0x38, 0x0a, 0x0e, 0x85, 0x38, 0x0c, 0x0e, 0x84, 0x30, 0xa0, 0x0e, 0x90, 0xb5, 0x00,
	0x74, 0x12, 0x3b, 0x80, 0x02, 0x2b, 0x9b, 0xe0, 0xe2, 0x4a, 0x38, 0x0a, 0x0e, 0x8f, 0x38, 0x0c,
	0x0e, 0x86, 0xa2, 0x17, 0x7e, 0x9c, 0x3b, 0x64, 0x40, 0x9e, 0x3b, 0x00, 0x40, 0x9f, 0x34, 0x00,
	0x0e, 0x8d, 0x34, 0x01, 0x0e, 0x8d, 0x38, 0x0a, 0x0e, 0x90, 0x38, 0x0c, 0x0e, 0x87, 0xa2, 0x17,
	0x7e, 0x9c, 0x3b, 0x64, 0x40, 0xa5, 0x3b, 0x00, 0x40, 0xa6, 0x34, 0x00, 0x0e, 0x8e, 0x34, 0x01,
	0x0e, 0x8e, 0x3b, 0x80, 0x05, 0xb6, 0xb5, 0x00, 0x7e, 0x9c, 0x7f, 0x4e, 0x54, 0xbe, 0xb5, 0x00,
	0x44, 0x88, 0x38, 0x0c, 0x0e, 0x8d, 0x38, 0x0e, 0x0e, 0x81, 0x38, 0x00, 0x0e, 0x80, 0x82, 0x18,
	0x7e, 0x9c, 0x3a, 0x81, 0x00, 0x29, 0x3b, 0x43, 0x40, 0xbf, 0x38, 0x0c, 0x0e, 0x8c, 0x9b, 0xbf,
	0xd5, 0x37, 0xa2, 0x13, 0xfe, 0x9c, 0x3b, 0x64, 0x40, 0xbf, 0xa2, 0x10, 0x7e, 0x9c, 0x3b, 0x67,
	0x40, 0xbf, 0x38, 0x08, 0x0e, 0x88, 0xd0, 0x45, 0x54, 0xb5, 0x3a, 0x89, 0x00, 0x50, 0xb5, 0x00,
	0x12, 0x61, 0xfb, 0x00, 0x71, 0x40, 0xba, 0x38, 0x0e, 0x02, 0x7f, 0x95, 0xd8, 0xc3, 0xc0, 0xb3,
	0xd3, 0x7e, 0x9c, 0x3b, 0x00, 0x40, 0xce, 0x38, 0x0d, 0x0e, 0x8c, 0x38, 0x02, 0x0e, 0x8e, 0x82,
	0x04, 0x7e, 0x9c, 0x3b, 0x43, 0x40, 0xc7, 0x7f, 0x20, 0x42, 0xd0, 0xa2, 0x13, 0xfe, 0x9c, 0x3b,
	0x64, 0x40, 0xc7, 0xa2, 0x10, 0x7e, 0x9c, 0x3b, 0x66, 0x40, 0xce, 0x38, 0x08, 0x0e, 0x89, 0xd0,
	0x44, 0x7e, 0x9c, 0x38, 0x0c, 0x0e, 0x8a, 0xb5, 0x00, 0x61, 0x00, 0x95, 0x90, 0xfe, 0x9c, 0xb2,
	0xda, 0x7e, 0x9c, 0x38, 0x0d, 0x0e, 0x8c, 0x6a, 0x1d, 0xd4, 0xbd, 0x61, 0x00, 0x43, 0x08, 0xa2,
	0x13, 0x7e, 0x9c, 0x3a, 0x89, 0xff, 0xeb, 0x3b, 0x46, 0x40, 0xd6, 0xb5, 0x00, 0x54, 0xf7, 0x3a,
	0x88, 0xff, 0x93, 0xb5, 0x00, 0x42, 0xd0, 0xb5, 0x00, 0x42, 0x88, 0x82, 0x14, 0x54, 0x35, 0x3a,
	0x80, 0x00, 0x5d, 0x3a, 0x89, 0xff, 0xa5, 0xb5, 0x00, 0x55, 0x3c, 0x3b, 0x43, 0x40, 0xeb, 0x6a,
	0x3e, 0x54, 0xfb, 0x3a, 0x82, 0x00, 0x98, 0x9b, 0xa0, 0xf8, 0x45, 0x31, 0x1f, 0xff, 0x69, 0x61,
	0xc8, 0x4c, 0x0d, 0x6a, 0x7e, 0xc5, 0x00, 0x6a, 0x1b, 0x72, 0x81, 0xb5, 0x00, 0x74, 0x55, 0x3b,
	0x80, 0x04, 0x39, 0x80, 0x18, 0x61, 0x85, 0x6a, 0x5c, 0xd5, 0x3d, 0x3b, 0x80, 0x1a, 0xf0, 0x3c,
	0xc8, 0xff, 0xd5, 0x3b, 0x00, 0x40, 0xec, 0xb5, 0x00, 0x54, 0xb7, 0xb5, 0x00, 0x54, 0xb7, 0x61,
	0x44, 0x7e, 0x9c, 0x98, 0xb5, 0x54, 0xbb, 0xb5, 0x00, 0x7e, 0x9c, 0x82, 0x14, 0x43, 0x08, 0x3b,
	0x63, 0x40, 0xf5, 0xb5, 0x00, 0x54, 0x36, 0x3b, 0x80, 0x02, 0x9c, 0x80, 0xb8, 0x74, 0x55, 0x3b,
	0x20, 0x40, 0xfe, 0x6a, 0x1a, 0xd4, 0xb8, 0x3a, 0x89, 0x00, 0x22, 0x3a, 0x80, 0x00, 0x14, 0xfb,
	0x00, 0x71, 0x40, 0xf8, 0x61, 0x04, 0x42, 0x80, 0xd0, 0x0c, 0x74, 0x55, 0x30, 0xa0, 0x07, 0x6c,
	0x94, 0x03, 0xd4, 0x36, 0x3b, 0x80, 0x01, 0xc7, 0xb5, 0x00, 0x61, 0x40, 0x9b, 0xa0, 0xd4, 0xbb,
	0x3a, 0x81, 0x00, 0x97, 0x61, 0xc4, 0x45, 0x04, 0x31, 0x0f, 0xff, 0x69, 0x6a, 0x3b, 0xcc, 0x05,
	0x6a, 0x5b, 0x72, 0x81, 0xb5, 0x00, 0x74, 0x15, 0x3b, 0x80, 0x04, 0x39, 0x80, 0x18, 0x61, 0x85,
	0x6a, 0x5c, 0xd5, 0x37, 0xb5, 0x00, 0x54, 0x36, 0x3b, 0x80, 0x19, 0x9a, 0xb5, 0x00, 0x7e, 0x9c,
	0x92, 0x13, 0xfe, 0x9c, 0x3b, 0x62, 0x41, 0x2a, 0x8b, 0x80, 0x54, 0xbc, 0x3a, 0x81, 0xff, 0xf1,
	0x60, 0x08, 0x78, 0x81, 0x38, 0x0a, 0x0e, 0x8c, 0xb5, 0x00, 0x4a, 0x00, 0xb3, 0x02, 0xc3, 0x08,
	0x90, 0xdb, 0xca, 0x40, 0x3a, 0x9a, 0x00, 0x11, 0xb2, 0xd3, 0x42, 0x98, 0x92, 0x17, 0xc3, 0x48,
	0xb5, 0x00, 0x48, 0x50, 0x3b, 0x42, 0x41, 0x28, 0xb5, 0x00, 0x54, 0x35, 0x3a, 0x98, 0x00, 0x5e,
	0xb5, 0x00, 0x43, 0x18, 0x82, 0x18, 0x7e, 0x9c, 0x3b, 0x66, 0x41, 0x28, 0x3a, 0x88, 0x00, 0x5f,
	0xb5, 0x00, 0x43, 0x08, 0x90, 0xd8, 0xfe, 0x9c, 0xa2, 0x1a, 0xc3, 0x48, 0x3b, 0x66, 0x41, 0x26,
	0x6c, 0x1d, 0x7e, 0x4a, 0x3b, 0x00, 0x41, 0x2b, 0xb5, 0x00, 0x7e, 0x48, 0x3b, 0x00, 0x41, 0x2b,
	0xb5, 0x00, 0x58, 0x3a, 0x3b, 0x00, 0x41, 0x2b, 0xb5, 0x00, 0x58, 0x3a, 0x9b, 0x9f, 0xd8, 0x3a,
	0x3c, 0xd8, 0x03, 0x00, 0x7f, 0x4e, 0x7d, 0x52, 0x3a, 0x88, 0x00, 0x0b, 0x9b, 0x8c, 0x42, 0x88,
	0xa6, 0x56, 0x7d, 0x05, 0x39, 0x02, 0x20, 0x24, 0xaa, 0x08, 0xc4, 0x00, 0x3a, 0x89, 0x00, 0xa7,
	0xba, 0x41, 0x58, 0x7b, 0xb5, 0x00, 0x5c, 0x7d, 0x3b, 0x80, 0x15, 0x07, 0xfb, 0x00, 0x71, 0x41,
	0x36, 0xba, 0x20, 0xda, 0x7c, 0x6d, 0x5e, 0x50, 0xbd, 0x3a, 0x91, 0x00, 0x18, 0x82, 0x04, 0x7e,
	0x50, 0x3a, 0x9a, 0xff, 0x65, 0x3a, 0x80, 0x00, 0x29, 0x3a, 0x93, 0x00, 0x95, 0x38, 0x08, 0x02,
	0x7f, 0x38, 0x0c, 0x0e, 0x8b, 0xbf, 0x10, 0x42, 0x40, 0x30, 0x10, 0x00, 0x20, 0x38, 0x0d, 0x0e,
	0x8c, 0xbb, 0x00, 0x40, 0xd8, 0x6a, 0xbe, 0x4c, 0x90, 0xb5, 0x00, 0x54, 0x7d, 0x31, 0x80, 0x20,
	0x07, 0x3b, 0x80, 0x02, 0xa3, 0x9b, 0xa2, 0xca, 0x48, 0x7f, 0x4e, 0x54, 0xbc, 0xb5, 0x00, 0x4c,
	0x88, 0x3a, 0x91, 0xff, 0x42, 0xb5, 0x00, 0x42, 0x90, 0x96, 0xf4, 0xd5, 0x3d, 0x3a, 0x81, 0xff,
	0x40, 0x61, 0x48, 0xfd, 0xa9, 0x3a, 0x88, 0x00, 0xb0, 0x61, 0x8a, 0x72, 0xe8, 0x6a, 0x7e, 0xc4,
	0x00, 0x30, 0x40, 0x00, 0x80, 0x30, 0x70, 0x02, 0xbc, 0x3b, 0x80, 0x1d, 0x08, 0xb5, 0x00, 0x55,
	0x7c, 0xb5, 0x00, 0x54, 0x3d, 0x3a, 0x88, 0x00, 0x0f, 0x62, 0x24, 0x44, 0x0a, 0x3a, 0x91, 0xff,
	0x4e, 0x30, 0x50, 0x00, 0x80, 0x3b, 0x80, 0x02, 0xc1, 0xb5, 0x00, 0x55, 0x7d, 0x6a, 0xde, 0x54,
	0xbd, 0x3a, 0x81, 0xff, 0xf3, 0x72, 0x22, 0xc2, 0x80, 0x30, 0xa0, 0x02, 0xf6, 0x61, 0x04, 0x42,
	0x98, 0x7b, 0x48, 0xf8, 0x05, 0x38, 0x0c, 0x20, 0x07, 0x7f, 0x2c, 0x43, 0x48, 0x6a, 0x3e, 0xc0,
	0x10, 0x69, 0x7f, 0xd2, 0x7e, 0x3b, 0x80, 0x1c, 0x44, 0x38, 0x01, 0x02, 0x7d, 0x30, 0x00, 0x00,
	0x20, 0xb9, 0x00, 0x54, 0x3d, 0x9b, 0x2b, 0x55, 0x3c, 0xb0, 0x04, 0x52, 0xbe, 0x38, 0x08, 0x20,
	0x01, 0xa6, 0xd0, 0x52, 0x3f, 0x3a, 0x80, 0x00, 0x10, 0x8b, 0x80, 0x42, 0x50, 0x9b, 0xa2, 0x42,
	0xc0, 0x3a, 0x88, 0x00, 0xb5, 0xb5, 0x00, 0x53, 0x7c, 0xfb, 0x00, 0x71, 0x41, 0x74, 0x31, 0x1f,
	0xff, 0xe9, 0x69, 0x3f, 0x44, 0x0d, 0x3b, 0x80, 0x02, 0xc1, 0xb5, 0x00, 0x54, 0xfd, 0x7f, 0x4e,
	0x54, 0x3d, 0xb5, 0x00, 0x44, 0x00, 0x3b, 0x80, 0x02, 0xc1, 0x9b, 0xa7, 0x7e, 0x9c, 0x7d, 0x8c,
	0x54, 0x3d, 0x7c, 0x24, 0xc4, 0x85, 0x6a, 0x3e, 0xd2, 0xbc, 0x61, 0x64, 0x44, 0x00, 0x3b, 0x80,
	0x04, 0xa4, 0x30, 0x50, 0x00, 0x80, 0x9b, 0xa2, 0x52, 0x3e, 0x90, 0x90, 0xd4, 0xbd, 0xa2, 0x12,
	0xfb, 0x24, 0xb5, 0x00, 0x4c, 0x8d, 0x3b, 0x44, 0x41, 0x74, 0x31, 0x10, 0x00, 0x1c, 0xb5, 0x00,
	0x4c, 0xcd, 0xb5, 0x00, 0x58, 0x3b, 0x3c, 0xd8, 0x03, 0x00, 0x8b, 0x80, 0x7d, 0x7b, 0xb5, 0x00,
	0x7e, 0x9c, 0x6a, 0xfc, 0x7d, 0x29, 0x3a, 0xa3, 0x00, 0x38, 0x6a, 0x7e, 0xc6, 0x9b, 0x3a, 0xad,
	0x00, 0x05, 0x6a, 0xfd, 0x56, 0xf9, 0x3a, 0xad, 0x00, 0x04, 0xb5, 0x00, 0x42, 0xa8, 0x82, 0x14,
	0x56, 0x7b, 0x6c, 0x3f, 0x55, 0x7c, 0xb5, 0x00, 0x74, 0x58, 0x3b, 0x42, 0x41, 0x9d, 0xb5, 0x00,
	0x42, 0x98, 0x3a, 0x9d, 0x00, 0x11, 0x3b, 0x80, 0x02, 0x9c, 0xb5, 0x00, 0x55, 0xff, 0x3b, 0x20,
	0x41, 0xa3, 0x9b, 0xc3, 0xd4, 0x38, 0x3a, 0x80, 0x00, 0x29, 0x3a, 0x90, 0x00, 0x10, 0x6a, 0xff,
	0xc4, 0x00, 0x3b, 0x80, 0x02, 0x4b, 0x80, 0xf4, 0x42, 0x90, 0x6a, 0x5e, 0x55, 0x38, 0x3b, 0x80,
	0x18, 0x74, 0x3c, 0xc8, 0xff, 0xd8, 0x9b, 0x00, 0xd4, 0x3a, 0x3a, 0x88, 0x00, 0x94, 0x80, 0xa0,
	0x45, 0x0a, 0x66, 0x04, 0x43, 0x80, 0x3a, 0x99, 0xff, 0x7e, 0x6a, 0x1e, 0x54, 0xbd, 0x3b, 0x80,
	0x04, 0x39, 0x80, 0xd4, 0x55, 0xfa, 0x30, 0x50, 0x66, 0x66, 0x6a, 0x5d, 0x52, 0xd7, 0xb5, 0x00,
	0x52, 0x97, 0x95, 0xd7, 0x43, 0x88, 0xfb, 0x00, 0x71, 0x41, 0xb2, 0xb3, 0xdf, 0x54, 0x3f, 0x61,
	0x40, 0x7e, 0x9c, 0xb5, 0x00, 0x55, 0xb9, 0x30, 0x70, 0x4c, 0xcd, 0x3a, 0x91, 0x00, 0x52, 0xb3,
	0xf7, 0xc2, 0x90, 0x3a, 0x9b, 0x00, 0x15, 0x3a, 0xa0, 0xff, 0xf8, 0x82, 0x14, 0x43, 0x48, 0x6a,
	0xff, 0xd6, 0x7a, 0x3b, 0x43, 0x41, 0xc6, 0x61, 0xe0, 0x54, 0xb8, 0x3a, 0x81, 0x00, 0x37, 0xb5,
	0x00, 0x43, 0x00, 0x82, 0x18, 0x7e, 0x9c, 0x3b, 0x62, 0x41, 0xc6, 0x3a, 0x81, 0x00, 0x8c, 0xb5,
	0x00, 0x43, 0x00, 0x82, 0x18, 0x7e, 0x9c, 0x3b, 0x63, 0x41, 0xde, 0x3a, 0x89, 0x00, 0x61, 0x3a,
	0x81, 0xff, 0xa1, 0x61, 0xc0, 0x43, 0x08, 0xb5, 0x00, 0x54, 0x7b, 0x3b, 0x80, 0x00, 0x48, 0x3c,
	0xc8, 0xff, 0xd8, 0x7f, 0x4e, 0x54, 0xbb, 0xb5, 0x00, 0x43, 0x08, 0x3a, 0x81, 0x00, 0x63, 0x7f,
	0x4e, 0x55, 0x3f, 0x61, 0x20, 0x42, 0x90, 0xb5, 0x00, 0x74, 0x58, 0x3b, 0x80, 0x02, 0x58, 0xb5,
	0x00, 0x62, 0x09, 0x7f, 0x4e, 0x54, 0x3b, 0xb5, 0x00, 0x42, 0x80, 0x3a, 0x88, 0x00, 0x36, 0x6a,
	0x7d, 0xd5, 0x3d, 0xb5, 0x00, 0x74, 0x18, 0x3b, 0x80, 0x02, 0x8a, 0xb5, 0x00, 0x62, 0x4a, 0x7f,
	0x24, 0x54, 0xbb, 0x3b, 0x00, 0x41, 0xe0, 0xb5, 0x00, 0x54, 0xba, 0x9b, 0xa0, 0xd4, 0xbb, 0x6a,
	0x5d, 0x42, 0xc8, 0xb5, 0x00, 0x7e, 0x9c, 0x9b, 0xc4, 0x42, 0x88, 0xa8, 0xb7, 0x7e, 0x9c, 0x82,
	0x14, 0x7e, 0x9c, 0x3b, 0x62, 0x41, 0xf2, 0x6a, 0x1c, 0xd4, 0xb8, 0x3a, 0x91, 0x00, 0x14, 0x3a,
	0x88, 0x00, 0x1d, 0x61, 0x48, 0x43, 0x08, 0x3a, 0x82, 0xff, 0xee, 0xd0, 0x4c, 0x43, 0x00, 0xb5,
	0x00, 0x54, 0xbc, 0x94, 0x02, 0x62, 0x09, 0x30, 0xa0, 0x07, 0xe0, 0x3b, 0x80, 0x01, 0xc7, 0xb5,
	0x00, 0x61, 0x40, 0x1b, 0x00, 0x71, 0x41, 0xf0, 0x3b, 0x00, 0x41, 0xf3, 0xb5, 0x00, 0x58, 0x3e,
	0xb5, 0x00, 0x58, 0x3e, 0x3c, 0xd8, 0x03, 0x00, 0x8b, 0x80, 0x7d, 0x57, 0xb5, 0x00, 0x7e, 0x9c,
	0x03, 0x00, 0x70, 0x00, 0x07, 0x2a, 0x00, 0x71, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0f, 0x74,
	0x00, 0x40, 0x00, 0x00, 0x3b, 0x80, 0x00, 0x00, 0x01, 0x00, 0x0f, 0x9c, 0x00, 0x41, 0x8d, 0x00,
	0x3b, 0x80, 0x00, 0x00, 0x01, 0x00, 0x10, 0x21, 0x00, 0x41, 0x2d, 0x00, 0x3b, 0x80, 0x00, 0x00,
	0x00, 0x06, 0x00, 0x71, 0x03, 0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x71, 0x03, 0x14, 0x00, 0x00,
	0x00, 0x06, 0x00, 0x71, 0x03, 0x18, 0x00, 0x00, 0x00, 0x06, 0x00, 0x71, 0x03, 0x1c, 0x00, 0x00,
	0x00, 0x06, 0x00, 0x71, 0x03, 0x20, 0x00, 0x00, 0x00, 0x06, 0x00, 0x71, 0x03, 0x24, 0x00, 0x00,
	0x00, 0x03, 0x00, 0x70, 0x00, 0x03, 0x09, 0x00, 0x71, 0x02, 0x7e, 0x00, 0x0e, 0x00, 0x01, 0x47,
	0xae, 0x06, 0x00, 0x71, 0x02, 0xff, 0x10, 0x00, 0x00, 0x36, 0x00, 0x71, 0x0e, 0x80, 0x00, 0x00,
	0x3c, 0x00, 0x00, 0x05, 0x70, 0x05, 0xad, 0x7f, 0xd4, 0x56, 0x7f, 0xf7, 0x43, 0x70, 0x05, 0xad,
	0x06, 0x66, 0x66, 0x19, 0x99, 0x99, 0x40, 0x07, 0x93, 0x3f, 0xff, 0xd0, 0x02, 0xcc, 0xcd, 0x09,
	0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x7f, 0xff,
	0xff, 0x06, 0x00, 0x71, 0x12, 0xbf, 0x01, 0x07, 0x01, 0x03, 0x00, 0x70, 0x00, 0x00, 0x03, 0x00,
	0x40, 0x5a, 0x6b, 0x03, 0x00, 0x57, 0x04, 0x00, 0x03, 0x00, 0x40, 0x00, 0x00, 0x03, 0x00, 0x06,
	0x00, 0x01
};
static struct firmware fw_tfa9890_rom_patch = {
	.size = sizeof(fw_data_tfa9890_rom_patch),
	.data = fw_data_tfa9890_rom_patch,
	.pages = NULL,
	.priv = NULL,
};

static int tfa98xx_firmware_init_put(const int id, const char *name, struct tfa98xx_priv *tfa98xx, const struct firmware * fw)
{
        pr_info("%s: %d: %s\n", __func__, id, name);

        mutex_lock(&tfa98xx->fw_lock);
        strcpy(tfa98xx->fw_name[id], name);
        if (tfa98xx->fw[id] == NULL || /* no firmware yet */
            tfa98xx->fw[id]->size != fw->size || /* or change */
            memcmp(tfa98xx->fw[id]->data, fw->data, fw->size)) {
                tfa98xx->fw_chg[id] = true;
                swap(tfa98xx->fw[id], fw);
        }
        mutex_unlock(&tfa98xx->fw_lock);

        /* download in the background to unblock
           the caller to turn on the clock */
        tfa98xx_start_download(tfa98xx, false);
        return 0;
}

static int tfa98xx_firmware_init(struct snd_soc_codec *codec, struct tfa98xx_priv *tfa98xx)
{
        struct i2c_client *client = to_i2c_client(codec->dev);
        struct device_node *np = client->dev.of_node;
        const char *p;

        if (of_property_read_string(np, "nxt,fw-boot", &p) == 0) {
                tfa98xx_firmware_init_put(0, "tfa9890_boot.patch", tfa98xx, &fw_tfa9890_boot_patch);
        }
        if (of_property_read_string(np, "nxt,fw-rom", &p) == 0) {
                tfa98xx_firmware_init_put(1, "tfa9890_rom.patch", tfa98xx, &fw_tfa9890_rom_patch);
        }
        if (of_property_read_string(np, "nxt,fw-speaker", &p) == 0) {
                if (strcmp(p, "tfa9890_left.speaker") == 0)
                    tfa98xx_firmware_init_put(2, "tfa9890_left.speaker", tfa98xx, &fw_tfa9890_left_speaker);
                else
                    tfa98xx_firmware_init_put(2, "tfa9890_right.speaker", tfa98xx, &fw_tfa9890_right_speaker);
        }
        if (of_property_read_string(np, "nxt,fw-config", &p) == 0) {
                tfa98xx_firmware_init_put(3, "tfa9890.config", tfa98xx, &fw_tfa9890_config);
        }
        if (of_property_read_string(np, "nxt,fw-preset", &p) == 0) {
                if (strcmp(p, "tfa9890_left_music.preset") == 0)
                    tfa98xx_firmware_init_put(4, "tfa9890_left_music.preset", tfa98xx, &fw_tfa9890_left_music_preset);
                else
                    tfa98xx_firmware_init_put(4, "tfa9890_right_music.preset", tfa98xx, &fw_tfa9890_right_music_preset);
        }
        if (of_property_read_string(np, "nxt,fw-eq", &p) == 0) {
                if (strcmp(p, "tfa9890_left_music.eq") == 0)
                    tfa98xx_firmware_init_put(5, "tfa9890_left_music.eq", tfa98xx, &fw_tfa9890_left_music_eq);
                else
                    tfa98xx_firmware_init_put(5, "tfa9890_right_music.eq", tfa98xx, &fw_tfa9890_right_music_eq);
        }
        return 0;
}

static int tfa98xx_probe(struct snd_soc_codec *codec)
{
	struct tfa98xx_priv *tfa98xx;
	int ret;

	tfa98xx = kzalloc(sizeof(struct tfa98xx_priv), GFP_KERNEL);
	if (tfa98xx == NULL) {
		dev_err(codec->dev, "Failed to alloc tfa98xx_priv\n");
		return -ENOMEM;
	}

	tfa98xx->codec = codec;
	mutex_init(&tfa98xx->fw_lock);

	INIT_DELAYED_WORK(&tfa98xx->monitor_work, tfa98xx_monitor);
	INIT_DELAYED_WORK(&tfa98xx->download_work, tfa98xx_download);

	codec->bulk_write_raw = tfa98xx_bulk_write;
	snd_soc_codec_set_drvdata(codec, tfa98xx);

	tfa98xx->workqueue = create_singlethread_workqueue(dev_name(codec->dev));
	if (tfa98xx->workqueue == NULL) {
		dev_err(codec->dev, "Failed to create workqueue\n");
		ret = -ENOMEM;
		goto wq_fail;
	}

	tfa98xx_firmware_init(codec, tfa98xx);

	ret = tfa98xx_reset(codec);
	if (ret < 0) {
		dev_err(codec->dev, "Failed to reset tf98xx(%d)\n", ret);
		goto reset_fail;
	}

	device_create_file(codec->dev, &dev_attr_dsp_crash);
	device_create_file(codec->dev, &dev_attr_pilot_tone);

	return ret;

reset_fail:
	destroy_workqueue(tfa98xx->workqueue);
wq_fail:
	kfree(tfa98xx);
	return ret;
}

static int tfa98xx_remove(struct snd_soc_codec *codec)
{
	struct tfa98xx_priv *tfa98xx = snd_soc_codec_get_drvdata(codec);
	int id;

	tfa98xx_stop_monitor(tfa98xx);
	tfa98xx_stop_download(tfa98xx);
	destroy_workqueue(tfa98xx->workqueue);

	for (id = 0; id < TFA98XX_FW_NUMBER; id++)
		release_firmware(tfa98xx->fw[id]);
	kfree(tfa98xx);

	return 0;
}

static int tfa98xx_reg_addr_get(struct snd_kcontrol *kcontrol,
				struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct tfa98xx_priv *tfa98xx = snd_soc_codec_get_drvdata(codec);

	ucontrol->value.integer.value[0] = tfa98xx->reg_addr;
	return 0;
}

static int tfa98xx_reg_addr_put(struct snd_kcontrol *kcontrol,
				struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct tfa98xx_priv *tfa98xx = snd_soc_codec_get_drvdata(codec);

	tfa98xx->reg_addr = ucontrol->value.integer.value[0];
	return 0;
}

static int tfa98xx_reg_value_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct tfa98xx_priv *tfa98xx = snd_soc_codec_get_drvdata(codec);

	ucontrol->value.integer.value[0] = snd_soc_read(codec, tfa98xx->reg_addr);
	return 0;
}

static int tfa98xx_reg_value_put(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct tfa98xx_priv *tfa98xx = snd_soc_codec_get_drvdata(codec);

	return snd_soc_write(codec, tfa98xx->reg_addr, ucontrol->value.integer.value[0]);
}

static int tfa98xx_chsa_put(struct snd_kcontrol *kcontrol,
			    struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	bool bypass = ucontrol->value.enumerated.item[0] < 2;
	int ret;

	ret = snd_soc_update_bits_locked(codec, TFA98XX_SYS_CTRL,
		TFA98XX_SYS_CTRL_CFE_MSK, bypass ? 0 : TFA98XX_SYS_CTRL_CFE);
	if (ret < 0)
		return ret;

	return snd_soc_put_enum_double(kcontrol, ucontrol);
}

static int tfa98xx_bsst_get(struct snd_kcontrol *kcontrol,
			    struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	unsigned int bsss, bsst;

	bsss   = snd_soc_read(codec, TFA98XX_AUDIO_CTR);
	bsss  &= TFA989X_AUDIO_CTR_BSSS_MSK;
	bsss >>= TFA989X_AUDIO_CTR_BSSS_POS;

	bsst   = snd_soc_read(codec, TFA98XX_BAT_PROT);
	bsst  &= TFA989X_BAT_PROT_BSST_MSK;
	bsst >>= TFA989X_BAT_PROT_BSST_POS;

	ucontrol->value.enumerated.item[0] = (bsst << 1) | bsss;
	return 0;
}

static int tfa98xx_bsst_put(struct snd_kcontrol *kcontrol,
			    struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	unsigned int bsss = ucontrol->value.enumerated.item[0] & 1;
	unsigned int bsst = ucontrol->value.enumerated.item[0] >> 1;
	int ret;

	ret = snd_soc_update_bits_locked(codec, TFA98XX_AUDIO_CTR,
			TFA989X_AUDIO_CTR_BSSS_MSK,
			bsss << TFA989X_AUDIO_CTR_BSSS_POS);
	if (ret < 0)
		return ret;

	ret = snd_soc_update_bits(codec, TFA98XX_BAT_PROT,
			TFA989X_BAT_PROT_BSST_MSK,
			bsst << TFA989X_BAT_PROT_BSST_POS);
	if (ret < 0)
		return ret;

	return ret;
}

static int tfa98xx_recalib_get(struct snd_kcontrol *kcontrol,
			       struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct tfa98xx_priv *tfa98xx = snd_soc_codec_get_drvdata(codec);

	ucontrol->value.integer.value[0] = tfa98xx->recalib;
	return 0;
}

static int tfa98xx_recalib_put(struct snd_kcontrol *kcontrol,
			       struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct tfa98xx_priv *tfa98xx = snd_soc_codec_get_drvdata(codec);

	tfa98xx->recalib = !!ucontrol->value.integer.value[0];
	if (tfa98xx->recalib)
		tfa98xx_start_download(tfa98xx, true);

	return 0;
}

static int tfa98xx_firmware_info(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_info *uinfo)
{
	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
	uinfo->count = 512;
	return 0;
}

static int tfa98xx_firmware_get(struct snd_kcontrol *kcontrol,
				struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct tfa98xx_priv *tfa98xx = snd_soc_codec_get_drvdata(codec);
	unsigned long id = kcontrol->private_value;

	strcpy(ucontrol->value.bytes.data, tfa98xx->fw_name[id]);
	return 0;
}

static int tfa98xx_firmware_put(struct snd_kcontrol *kcontrol,
				struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct tfa98xx_priv *tfa98xx = snd_soc_codec_get_drvdata(codec);
	unsigned long id = kcontrol->private_value;
	const char *name = ucontrol->value.bytes.data;
	const struct firmware *fw;
	int ret;

	ret = request_firmware(&fw, name, codec->dev);
	if (ret < 0) {
		dev_err(codec->dev, "Failed to request %s(%d)\n", name, ret);
		return ret;
	}

	mutex_lock(&tfa98xx->fw_lock);
	strcpy(tfa98xx->fw_name[id], name);
	if (tfa98xx->fw[id] == NULL || /* no firmware yet */
	    tfa98xx->fw[id]->size != fw->size || /* or change */
	    memcmp(tfa98xx->fw[id]->data, fw->data, fw->size)) {
		tfa98xx->fw_chg[id] = true;
		swap(tfa98xx->fw[id], fw);
	}
	mutex_unlock(&tfa98xx->fw_lock);

	/* download in the background to unblock
	   the caller to turn on the clock */
	tfa98xx_start_download(tfa98xx, false);

	release_firmware(fw);
	return ret;
}

#define TFA98XX_FIRMWARE(xname, id) \
	{ \
		.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
		.name = xname, \
		.info = tfa98xx_firmware_info, \
		.get = tfa98xx_firmware_get, \
		.put = tfa98xx_firmware_put, \
		.private_value = id, \
	}

static const char * const tfa98xx_chs12_text[] = {
	"Left", "Right", "Mono",
};
static const unsigned int tfa98xx_chs12_value[] = {
	1, 2, 3,
};
static const SOC_VALUE_ENUM_SINGLE_DECL(
	tfa98xx_chs12_enum, TFA98XX_I2SREG,
	TFA98XX_I2SREG_CHS12_POS, TFA98XX_I2SREG_CHS12_MAX,
	tfa98xx_chs12_text, tfa98xx_chs12_value);

static const char * const tfa98xx_chs3_text[] = {
	"Left", "Right",
};
static const SOC_ENUM_SINGLE_DECL(
	tfa98xx_chs3_enum, TFA98XX_I2SREG,
	TFA98XX_I2SREG_CHS3_POS, tfa98xx_chs3_text);

static const char * const tfa98xx_chsa_text[] = {
	"Left", "Right", "DSP",
};
static const SOC_ENUM_SINGLE_DECL(
	tfa98xx_chsa_enum, TFA98XX_I2SREG,
	TFA98XX_I2SREG_CHSA_POS, tfa98xx_chsa_text);

static const char * const tfa98xx_i2sdoc_text[] = {
	"DSP", "DATAI1", "DATAI2", "DATAI3",
};
static const SOC_ENUM_SINGLE_DECL(
	tfa98xx_i2sdoc_enum, TFA98XX_I2SREG,
	TFA9890_I2SREG_I2SDOC_POS, tfa98xx_i2sdoc_text);

static const char * const tfa98xx_bsst_text[] = {
	"2.73V", "2.99V", "2.83V", "3.09V", "2.93V", "3.19V", "3.03V", "3.29V",
	"3.13V", "3.39V", "3.23V", "3.49V", "3.33V", "3.59V", "3.43V", "3.69V",
	"3.53V", "3.79V", "3.63V", "3.89V", "3.73V", "3.99V", "3.83V", "4.09V",
	"3.93V", "4.19V", "4.03V", "4.29V", "4.13V", "4.39V", "4.23V", "4.49V",
};
static const SOC_ENUM_SINGLE_EXT_DECL(
	tfa98xx_bsst_enum, tfa98xx_bsst_text);

static const DECLARE_TLV_DB_SCALE(
	tfa98xx_vol_tlv, -12750, 50, 0);

static const char * const tfa98xx_dcvo_text[] = {
	"6.0V", "6.5V", "7.0V", "7.5V", "8.0V", "8.5V", "9.0V", "9.5V",
};
static const SOC_ENUM_SINGLE_DECL(
	tfa98xx_dcvo_enum, TFA98XX_DCDCBOOST,
	TFA98XX_DCDCBOOST_DCVO_POS, tfa98xx_dcvo_text);

static const char * const tfa98xx_dcmcc_text[] = {
	"0.5A", "1.0A", "1.4A", "1.9A", "2.4A", "2.9A", "3.3A", "3.8A",
};
static const SOC_ENUM_SINGLE_DECL(
	tfa98xx_dcmcc_enum, TFA98XX_DCDCBOOST,
	TFA98XX_DCDCBOOST_DCMCC_POS, tfa98xx_dcmcc_text);

static const char * const tfa98xx_isel_text[] = {
	"Input1", "Input2",
};
static const SOC_ENUM_SINGLE_DECL(
	tfa98xx_isel_enum, TFA98XX_SYS_CTRL,
	TFA98XX_SYS_CTRL_ISEL_POS, tfa98xx_isel_text);

static const char * const tfa98xx_dccv_text[] = {
	"0.7uH", "1uH", "1.5uH", "2.2uH",
};
static const SOC_ENUM_SINGLE_DECL(
	tfa98xx_dccv_enum, TFA98XX_SYS_CTRL,
	TFA98XX_SYS_CTRL_DCCV_POS, tfa98xx_dccv_text);

static const char * const tfa98xx_spkr_text[] = {
	"Auto", "4Omh", "6Omh", "8Omh",
};
static const SOC_ENUM_SINGLE_DECL(
	tfa98xx_spkr_enum, TFA98XX_I2S_SEL_REG,
	TFA98XX_I2S_SEL_REG_SPKR_POS, tfa98xx_spkr_text);

static const char * const tfa98xx_spkl_text[] = {
	"22uH", "27uH", "33uH", "39uH", "47uH", "56uH", "68uH", "82uH",
};
static const SOC_ENUM_SINGLE_DECL(
	tfa98xx_spkl_enum, TFA98XX_I2S_SEL_REG,
	TFA98XX_I2S_SEL_REG_SPKL_POS, tfa98xx_spkl_text);

static const char * const tfa98xx_dos_text[] = {
	"Current", "Gain", "AEC", "Voltage", "DATAI3 Right", "DATAI3 Left",
};
static const SOC_ENUM_DOUBLE_DECL(
	tfa98xx_dos_enum, TFA98XX_I2S_SEL_REG,
	TFA98XX_I2S_SEL_REG_DOLS_POS, TFA98XX_I2S_SEL_REG_DORS_POS,
	tfa98xx_dos_text);

static const struct snd_kcontrol_new tfa98xx_controls[] = {
	SOC_SINGLE_EXT("Reg Addr", SND_SOC_NOPM, 0, 0x8F, 0,
		tfa98xx_reg_addr_get, tfa98xx_reg_addr_put),
	SOC_SINGLE_EXT("Reg Value", SND_SOC_NOPM, 0, 0xFFFFFF, 0,
		tfa98xx_reg_value_get, tfa98xx_reg_value_put),
	SOC_SINGLE("Battery Voltage", TFA98XX_BATTERYVOLTAGE,
		TFA98XX_BATTERYVOLTAGE_BATS_POS, TFA98XX_BATTERYVOLTAGE_BATS_MAX, 0),
	SOC_SINGLE("Temperature", TFA98XX_TEMPERATURE,
		TFA98XX_TEMPERATURE_TEMPS_POS, TFA98XX_TEMPERATURE_TEMPS_MAX, 0),
	SOC_VALUE_ENUM("Input Channel Mux", tfa98xx_chs12_enum),
	SOC_ENUM("Gain Channel Mux", tfa98xx_chs3_enum),
	SOC_ENUM_EXT("Amplifier Channel Mux", tfa98xx_chsa_enum,
		snd_soc_get_enum_double, tfa98xx_chsa_put),
	SOC_ENUM("Output Interface Mux", tfa98xx_i2sdoc_enum),
	SOC_ENUM_EXT("Safeguard Threshold", tfa98xx_bsst_enum,
		tfa98xx_bsst_get, tfa98xx_bsst_put),
	SOC_SINGLE("Safeguard Bypass", TFA98XX_BAT_PROT,
		TFA989X_BAT_PROT_BSSBY_POS, TFA989X_BAT_PROT_BSSBY_MAX, 0),
	SOC_SINGLE_TLV("Digital Volume", TFA98XX_AUDIO_CTR,
		TFA98XX_AUDIO_CTR_VOL_POS, TFA98XX_AUDIO_CTR_VOL_MAX,
		1, tfa98xx_vol_tlv),
	SOC_ENUM("Output Voltage", tfa98xx_dcvo_enum),
	SOC_ENUM("Max Coil Current", tfa98xx_dcmcc_enum),
	SOC_SINGLE("Use External Temperature", TFA98XX_SPKR_CALIBRATION,
		TFA98XX_SPKR_CALIBRATION_TROS_POS, TFA98XX_SPKR_CALIBRATION_TROS_MAX, 0),
	SOC_SINGLE("External Temperature", TFA98XX_SPKR_CALIBRATION,
		TFA98XX_SPKR_CALIBRATION_EXTTS_POS, TFA98XX_SPKR_CALIBRATION_EXTTS_MAX, 0),
	SOC_ENUM("Input Interface Mux", tfa98xx_isel_enum),
	SOC_ENUM("Coil Value", tfa98xx_dccv_enum),
	SOC_ENUM("Resistance", tfa98xx_spkr_enum),
	SOC_ENUM("Inductance", tfa98xx_spkl_enum),
	SOC_ENUM("Output Channel Mux", tfa98xx_dos_enum),
	SOC_SINGLE_BOOL_EXT("Recalibrate", 0,
		tfa98xx_recalib_get, tfa98xx_recalib_put),
	TFA98XX_FIRMWARE("Boot Patch", TFA98XX_FW_BOOT),
	TFA98XX_FIRMWARE("ROM Patch", TFA98XX_FW_ROM),
	TFA98XX_FIRMWARE("Speaker File", TFA98XX_FW_SPEAKER),
	TFA98XX_FIRMWARE("Config File", TFA98XX_FW_CONFIG),
	TFA98XX_FIRMWARE("Preset File", TFA98XX_FW_PRESET),
	TFA98XX_FIRMWARE("Equalizer File", TFA98XX_FW_EQUALIZER),
};

static const struct snd_soc_dapm_route tfa98xx_routes[] = {
	{ "Capture", NULL, "Playback" },
};

static const u16 tfa98xx_reg[0x90] = {
	[TFA98XX_I2SREG] =             0x888B,
	[TFA98XX_BAT_PROT] =           0x9392,
	[TFA98XX_AUDIO_CTR] =          0x000F,
	[TFA98XX_DCDCBOOST] =          0x8FFF,
	[TFA98XX_SPKR_CALIBRATION] =   0x3800,
	[TFA98XX_SYS_CTRL] =           0x824D,
	[TFA98XX_I2S_SEL_REG] =        0x3EC3,


	[TFA98XX_INTERRUPT_REG] =      0x0040,


	[TFA98XX_CURRENTSENSE4] =      0xAD93,
};

static int tfa98xx_volatile_register(struct snd_soc_codec *codec, unsigned int reg)
{
	switch (reg) {
	case TFA98XX_I2SREG:
	case TFA98XX_BAT_PROT:
	case TFA98XX_AUDIO_CTR:
	case TFA98XX_DCDCBOOST:
	case TFA98XX_SPKR_CALIBRATION:
	case TFA98XX_SYS_CTRL:
	case TFA98XX_I2S_SEL_REG:
	case TFA98XX_INTERRUPT_REG:
	case TFA98XX_CURRENTSENSE4:
		return 0;
	default:
		return 1;
	}
}

static int tfa98xx_writable_register(struct snd_soc_codec *codec, unsigned int reg)
{
	switch (reg) {
	case TFA98XX_STATUSREG:
	case TFA98XX_BATTERYVOLTAGE:
	case TFA98XX_TEMPERATURE:
	case TFA98XX_REVISIONNUMBER:
	case TFA9890_MTPF:
		return 0;
	default:
		return 1;
	}
}

static const struct snd_soc_codec_driver tfa98xx_drv = {
	.probe = tfa98xx_probe,
	.remove = tfa98xx_remove,
	.controls = tfa98xx_controls,
	.num_controls = ARRAY_SIZE(tfa98xx_controls),
	.dapm_routes = tfa98xx_routes,
	.num_dapm_routes = ARRAY_SIZE(tfa98xx_routes),
	.read = tfa98xx_read,
	.write = tfa98xx_write,
	.volatile_register = tfa98xx_volatile_register,
	.writable_register = tfa98xx_writable_register,
	.reg_cache_size = ARRAY_SIZE(tfa98xx_reg),
	.reg_word_size = sizeof(tfa98xx_reg[0]),
	.reg_cache_default = tfa98xx_reg,
	.idle_bias_off = 1,
};

#define TFA98XX_FORMATS			(SNDRV_PCM_FMTBIT_S16_LE  | \
					 SNDRV_PCM_FMTBIT_S18_3LE | \
					 SNDRV_PCM_FMTBIT_S20_3LE | \
					 SNDRV_PCM_FMTBIT_S24_LE)

#define TFA98XX_RATES			SNDRV_PCM_RATE_8000_48000

static int tfa98xx_set_format(struct snd_soc_dai *codec_dai, unsigned int fmt)
{
	struct snd_soc_codec *codec = codec_dai->codec;
	struct tfa98xx_priv *tfa98xx = snd_soc_codec_get_drvdata(codec);

	/* interface format */
	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
	case SND_SOC_DAIFMT_I2S:
	case SND_SOC_DAIFMT_RIGHT_J:
	case SND_SOC_DAIFMT_LEFT_J:
		break;
	default:
		dev_err(codec->dev, "Invalid interface format\n");
		return -EINVAL;
	}

	/* clock inversion */
	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
	case SND_SOC_DAIFMT_NB_NF:
		break;
	default:
		dev_err(codec->dev, "Invalid clock inversion\n");
		return -EINVAL;
	}

	/* set master/slave audio interface */
	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
	case SND_SOC_DAIFMT_CBS_CFS:
		break;
	default:
		dev_err(codec->dev, "Invalid master/slave setting\n");
		return -EINVAL;
	}

	/* save for later use */
	tfa98xx->fmt = fmt;
	return 0;
}

static int tfa98xx_digital_mute(struct snd_soc_dai *codec_dai, int mute)
{
	struct snd_soc_codec *codec = codec_dai->codec;
	struct tfa98xx_priv *tfa98xx = snd_soc_codec_get_drvdata(codec);

	if (mute) {
		tfa98xx_stop_monitor(tfa98xx);
		tfa98xx_stop_download(tfa98xx);
		tfa98xx_mute(codec, TFA98XX_MUTE_AMPLIFIER);
		tfa98xx_power(codec, false);
		usleep_range(5000, 5000);
	} else {
		usleep_range(5000, 5000);
		tfa98xx_power(codec, true);
		if (tfa98xx_start_download(tfa98xx, false))
			; /* will turn off the mute after download */
		else
			tfa98xx_mute(codec, TFA98XX_MUTE_OFF);
		tfa98xx_start_monitor(tfa98xx);
	}

	return 0;
}

static int tfa98xx_hw_params(struct snd_pcm_substream *substream,
			     struct snd_pcm_hw_params *params,
			     struct snd_soc_dai *dai)
{
	struct snd_soc_codec *codec = dai->codec;
	struct tfa98xx_priv *tfa98xx = snd_soc_codec_get_drvdata(codec);
	unsigned int value = 0;

	switch (tfa98xx->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
	case SND_SOC_DAIFMT_I2S:
		value |= TFA98XX_I2SCTRL_PHILIPS;
		break;
	case SND_SOC_DAIFMT_RIGHT_J:
		switch (params_format(params)) {
		case SNDRV_PCM_FORMAT_S16_LE:
			value |= TFA98XX_I2SCTRL_LSB_J_16;
			break;
		case SNDRV_PCM_FORMAT_S18_3LE:
			value |= TFA98XX_I2SCTRL_LSB_J_18;
			break;
		case SNDRV_PCM_FORMAT_S20_3LE:
			value |= TFA98XX_I2SCTRL_LSB_J_20;
			break;
		case SNDRV_PCM_FORMAT_S24_LE:
			value |= TFA98XX_I2SCTRL_LSB_J_24;
			break;
		default:
			return -EINVAL;
		}
		break;
	case SND_SOC_DAIFMT_LEFT_J:
		value |= TFA98XX_I2SCTRL_MSB_J;
		break;
	default:
		dev_err(codec->dev, "Invalid dai format = %d\n", tfa98xx->fmt);
		return -EINVAL;
	}

	switch (params_rate(params)) {
	case 48000:
		value |= TFA98XX_I2SCTRL_RATE_48000;
		break;
	case 44100:
		value |= TFA98XX_I2SCTRL_RATE_44100;
		break;
	case 32000:
		value |= TFA98XX_I2SCTRL_RATE_32000;
		break;
	case 24000:
		value |= TFA98XX_I2SCTRL_RATE_24000;
		break;
	case 22050:
		value |= TFA98XX_I2SCTRL_RATE_22050;
		break;
	case 16000:
		value |= TFA98XX_I2SCTRL_RATE_16000;
		break;
	case 12000:
		value |= TFA98XX_I2SCTRL_RATE_12000;
		break;
	case 11025:
		value |= TFA98XX_I2SCTRL_RATE_11025;
		break;
	case 8000:
		value |= TFA98XX_I2SCTRL_RATE_08000;
		break;
	default:
		return -EINVAL;
	}

	return snd_soc_update_bits_locked(codec, TFA98XX_I2SREG,
			TFA98XX_I2SREG_I2SSR_MSK | TFA98XX_I2SREG_I2SF_MSK, value);
}

static const struct snd_soc_dai_ops tfa98xx_dai_ops = {
	.set_fmt = tfa98xx_set_format,
	.digital_mute = tfa98xx_digital_mute,
	.hw_params = tfa98xx_hw_params,
};

static struct snd_soc_dai_driver tfa98xx_dai = {
	.name = "tfa98xx-dai",
	.ops = &tfa98xx_dai_ops,
	.capture = {
		.stream_name = "Capture",
		.formats = TFA98XX_FORMATS,
		.rates = TFA98XX_RATES,
		.channels_min = 2,
		.channels_max = 2,
	},
	.playback = {
		.stream_name = "Playback",
		.formats = TFA98XX_FORMATS,
		.rates = TFA98XX_RATES,
		.channels_min = 2,
		.channels_max = 2,
	},
	.symmetric_rates = 1,
};


static int tfa98xx_i2c_probe(struct i2c_client *client,
			     const struct i2c_device_id *id)
{
	return snd_soc_register_codec(&client->dev,
			&tfa98xx_drv, &tfa98xx_dai, 1);
}

static int tfa98xx_i2c_remove(struct i2c_client *client)
{
	snd_soc_unregister_codec(&client->dev);
	return 0;
}

static void tfa98xx_i2c_shutdown(struct i2c_client *client)
{
	struct tfa98xx_priv *tfa98xx = i2c_get_clientdata(client);

	if (tfa98xx)
		tfa98xx_power(tfa98xx->codec, false);
}

static const struct i2c_device_id tfa98xx_i2c_id[] = {
	{ "tfa98xx", 0 },
	{ }
};
MODULE_DEVICE_TABLE(i2c, tfa98xx_i2c_id);

#ifdef CONFIG_OF
static struct of_device_id tfa98xx_match[] = {
	{ .compatible = "nxp,tfa9890" },
	{ },
};
MODULE_DEVICE_TABLE(of, tfa98xx_match_tbl);
#endif

static struct i2c_driver tfa98xx_i2c_driver = {
	.driver = {
		.name = "tfa98xx",
		.owner = THIS_MODULE,
		.of_match_table = of_match_ptr(tfa98xx_match),
	},
	.probe = tfa98xx_i2c_probe,
	.remove = tfa98xx_i2c_remove,
	.shutdown = tfa98xx_i2c_shutdown,
	.id_table = tfa98xx_i2c_id,
};
module_i2c_driver(tfa98xx_i2c_driver);

MODULE_AUTHOR("Xiang Xiao <xiaoxiang@xiaomi.com>");
MODULE_DESCRIPTION("ASoC TFA98XX codec driver");
MODULE_LICENSE("GPL");
